{"meta":{"title":"Cjkkkk","subtitle":null,"description":null,"author":"Cjkkkk","url":"http://cjkkkk.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-10T12:08:59.000Z","updated":"2019-03-10T12:09:41.816Z","comments":true,"path":"about/index.html","permalink":"http://cjkkkk.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"patchmatch算法","slug":"patchmatch","date":"2019-04-04T17:36:49.000Z","updated":"2019-04-04T17:39:58.031Z","comments":true,"path":"2019/04/05/patchmatch/","link":"","permalink":"http://cjkkkk.github.io/2019/04/05/patchmatch/","excerpt":"","text":"patchmatch算法核心思想random sampling and data coherence 算法目的quickly finding approximate nearest neighbor matches between image patches 问题描述给定两张图像A B, 对图像A中的每个patch，找到图像B中与之匹配度最高的patch. 一些定义 NNF(nearest-neighbor field)定义NNF为$f: A \\rightarrow R^2$，假如图像A中的patch a与图像B中的patch b对应, $f(a) = b - a$, patch的坐标使用patch中心的坐标代替，同时需要定义距离函数$D$。 算法步骤问题简化为:为图像A中的每个patch a计算f(a)的值 initialization 初始化为图像A中的每一个patch a赋值随机的f(a)(在图像B中进行独立的均与采样(independent uniform sampling)) 或者使用prior information 迭代接下来的需要对每个像素迭代进行propagation和random search来改进f(a)的值, 遍历像素的顺序为从左到右，从上到下，且不是所有像素都完成propagation后进行random search，而是对每一个像素进行完propagation后立刻进行random search。 propagation 传播利用$f(x-1, y)$和$f(x, y-1)$的值来改进$f(x, y)$$f(x, y)$的新值是$min(D(f(x,y)), D(f(x-1, y)), D(x, y-1))$对应的$(x,y)$ $D$为距离函数 在偶数次迭代可以使用从右往左,从下往上的顺序迭代 random search 随机搜索$u_i = v_0 +wa^iR_i$$v_0 = f(x, y)$,$R_i$为$[-1,1]\\times[-1,1]$,$w$为搜索窗口大小,$a_i$为每次搜索窗口衰减的比例即以f(x, y)为中心的window进行搜索 停止条件即搜索半径小于等于1个像素:$wa^i &lt; 1$ 一幅图说明约定: 下文称f(a)为a的offset 需要搜索A图像中蓝色patch的offset, 红色patch是蓝色的left patch, 绿色patch是蓝色patch的up patch。 在( a )initialization中可以看到A图中3个颜色的patch被赋予了B图中随机的offset。 在( b )proagation中检查红色patch和绿色patch在B图中的offset是否比蓝色patch的offset更加match,可以看到红色的ofset更加match,于是更新蓝色patch的offset。 在( c ) random search中，以( b )中更新的offset为中心的window进行随机搜索。 重复( b )( c )步骤直到收敛。 GPU实现思路: propagation和random search阶段并行。 矛盾: propagation之前的CPU version是以scanline的形式进行，这意味着propagation是有先后顺序。 解决方案: jump flood scheme 分析假设图像A B都是M像素，考虑所有像素都被初始化到错误的offset的概率为$(1-1/M)^M$, 则至少有一个像素被初始化到正确的offset的概率为$1 - (1-1/M)^M$M很大的时候近似为$1 - 1/e$。 由于在random search阶段的时候，在小的邻域范围内的搜索是很密集的，可以认为只要在正确的offset一定领域内的offset都可以认为是正确的。 基于以上的考虑，propagation和random search可以大大加速算法的搜索速度。 参考PatchMatch: A Randomized Correspondence Algorithm for Structural Image Editing","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"BRDF","slug":"BRDF","date":"2019-03-22T12:12:04.000Z","updated":"2019-04-04T17:38:21.355Z","comments":true,"path":"2019/03/22/BRDF/","link":"","permalink":"http://cjkkkk.github.io/2019/03/22/BRDF/","excerpt":"","text":"参考原文 基于经验的模型Phong$I_{Phong} = K_aI_a + K_d(n·l) I_d + K_s(r·v)^\\alpha I_s$n法线，l入射向量，r反射向量，v观察向量，I代表光强，K代表物体颜射或者反射系数，a代表环境，s代表高光，d代表漫反射,$\\alpha$代表粗糙程度,值越小越粗糙。 blinn Phong(改进版本)$I_{Phong} = K_aI_a + K_d(n·l) I_d + K_s(n·h)^\\alpha I_s$h为半角(half angle)代表入射向量与观察向量的一半","categories":[],"tags":[{"name":"computer graphics","slug":"computer-graphics","permalink":"http://cjkkkk.github.io/tags/computer-graphics/"}]},{"title":"视觉中的特征点","slug":"key-point","date":"2019-03-15T16:04:52.000Z","updated":"2019-03-15T16:41:08.826Z","comments":true,"path":"2019/03/16/key-point/","link":"","permalink":"http://cjkkkk.github.io/2019/03/16/key-point/","excerpt":"","text":"定义特征点是图像中具有一定特点的/可识别的像素点 特点特征点应该具有的几个特点 相同的特征点在不同的图像中可以被找到(可重复性) 不同的特征点区别大(可区别性) 特征点数量应该远小于像素数量(高效性) 特征点应该仅仅与一小片区域相关(本地性) 组成特征点由关键点(key point)和描述子(descriptor)组成 关键点指的是该特征点在图像中的位置，有些特征点还具有朝向和大小等信息。 描述子是特征点按照认为设计的规则计算出的一个能描述周围像素信息的向量。比如根据特征点的方向信息选取周围的像素范围，统计像素的方向直方图分布进而描述这个像素周围的信息。 提取关键点，计算描述子 类别 SIFT Scale-Invariant Feature Transform 光照 尺度 旋转不变性 鲁棒 计算量大 CPU一般无法实时计算 FAST 关键点(没有描述子) ORB Oriented FAST and Rotated BRIEF 具有实时性 ORB计算FAST特征点看目标像素周围圆的像素的亮度 没有尺度和方向信息？尺度改进图像金字塔 方向改进灰度质心法(Intensity Centroid) BRIEF描述子计算匹配描述子 暴力搜索？ 欧式距离 vs. 汉明距离(二进制描述子) FLANN快速近似最近邻算法","categories":[],"tags":[{"name":"computer vision","slug":"computer-vision","permalink":"http://cjkkkk.github.io/tags/computer-vision/"}]},{"title":"c++特性","slug":"c-standard","date":"2019-03-14T16:51:11.000Z","updated":"2019-03-27T02:15:54.222Z","comments":true,"path":"2019/03/15/c-standard/","link":"","permalink":"http://cjkkkk.github.io/2019/03/15/c-standard/","excerpt":"","text":"c++ 11Lambda expressions1234// []() -&gt; T &#123;&#125;auto g = [](int x)&#123;return x * x;&#125;;std::cout &lt;&lt; g(3); // 9 作为predict12std::vector&lt;int&gt; s = &#123;1, 2, 3, 5&#125;;std::cout &lt;&lt; std::all_of(s.begin(), s.end(), [](int x) &#123; return x &gt; 0;&#125;) &lt;&lt; \"\\n\"; // 1 range-based for loop123456// for( range_declaration: range_expression) loop statementstd::vector&lt;int&gt; s = &#123;1, 2, 3, 4&#125;;for(auto&amp; i : s)&#123; std::cout &lt;&lt; i &lt;&lt; std::endl;&#125; unique_ptr参考链接 每一个unique_ptr与一个raw_ptr绑定,当unique_ptr out of scope, 会释放raw_ptr分配的内存 特点 无法copy或者assign，只能在unique_ptr之间用std::move进行移动 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;memory&gt;struct Task&#123; int mId; Task(int id ) :mId(id) &#123; std::cout&lt;&lt;\"Task::Constructor\"&lt;&lt;std::endl; &#125; ~Task() &#123; std::cout&lt;&lt;\"Task::Destructor\"&lt;&lt;std::endl; &#125;&#125;;int main()&#123; // Create a unique_ptr object through raw pointer std::unique_ptr&lt;Task&gt; taskPtr(new Task(23)); // auto taskPtr = new Task(23); //leak //Access the element through unique_ptr int id = taskPtr-&gt;mId; std::cout&lt;&lt;id&lt;&lt;std::endl; return 0;&#125; shared_ptr/weak_ptr","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://cjkkkk.github.io/tags/c/"}]},{"title":"相机标定 camera calibration","slug":"camera-calibration-using-chessboard","date":"2019-03-13T14:29:30.000Z","updated":"2019-03-14T16:13:27.149Z","comments":true,"path":"2019/03/13/camera-calibration-using-chessboard/","link":"","permalink":"http://cjkkkk.github.io/2019/03/13/camera-calibration-using-chessboard/","excerpt":"","text":"认识几个坐标系 世界坐标系 物体在真实世界中的位置 相机坐标系 物体在以相机为原点的坐标系中的位置 成像坐标系 在二维成像平面的位置 像素坐标系 在实际数字相片中的坐标 只有最后一个坐标系的单位是px，为实际图像中的坐标位置， 比如1080 * 720的图像就可以看成一个以图像左上角为原点建立的坐标系。 世界坐标系 -&gt; 相机坐标系 \\left[ \\begin{matrix} x\\\\ y\\\\ z \\end{matrix} \\right] = \\left[ \\begin{matrix} R & T\\\\ 0 & 1 \\end{matrix} \\right] \\left[ \\begin{matrix} X\\\\ Y\\\\ Z\\\\ 1 \\end{matrix} \\right] \\tag{1}R是3 * 3 的旋转矩阵 T是3 * 1的平移矩阵 0是1 * 3 的全部为0的矩阵 1为1 * 1的矩阵 所以可以看到4 * 4的变化矩阵乘以4 * 1的齐次坐标，结果应该为4 * 1的齐次坐标，这里结果为3 * 1是因为丢掉了齐次坐标中的最后为1的那个维度。 \\left[ \\begin{matrix} R & T\\\\ 0 & 1 \\end{matrix} \\right]矩阵也称为外参矩阵/相机的位姿 为什么需要齐次坐标呢？就是为了能用一个矩阵表达变化，后面不需要齐次坐标了所以可以丢掉最后一维。 相机坐标系-&gt;成像坐标系 \\left[ \\begin{matrix} x/z\\\\ y/z\\\\ 1 \\end{matrix} \\right]相当于投影到了相机坐标系中$z = 1$的平面 进行正畸几种畸变 径向畸变 透镜本身缺陷 桶形畸变 由于透镜摆放位置不平行光圈 成像坐标系-&gt;像素坐标系 \\left[ \\begin{matrix} u\\\\ v\\\\ 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_{corrected}/z\\\\ y_{corrected}/z\\\\ 1 \\end{matrix} \\right]其中 \\left[ \\begin{matrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{matrix} \\right]也被称为为相机的内参矩阵 成像平面的坐标系的原点是在中心的， 而像素平面的原点是在左上角的，向右边是u向下是v，u和v的单位都是px 内参矩阵相当于进行了二者的一个映射，即先乘以分辨率进行放缩，然后加上偏移量移动原点 相机标定相机标定需要确定的参数个数为9个$(f_x, f_y, c_x, c_y, k_1, k_2, k_3, p_1, p_2)$同时我们需要关注的是成像坐标系 -&gt; 像素坐标系，这里是内参矩阵作用的地方 对于K个棋盘照片，每一个棋盘中的N个角点，我们都有一个x, y的坐标，也就是我们能够得到2NK个等式 K个棋盘照片意味着有K个相机的位姿，即K个外参矩阵，也就是6K个参数。同时相机内参有4个参数，这意味着一共有6K + 4个参数。 2NK > 6K + 4 NK > 3K + 2 K(N-3) > 2如何确定标定板的三维坐标根据K个棋盘照片， 我们可以求得每个角点的像素坐标 然后我们可以以标定板所在平面为z=0的平面建立世界坐标系，同时设定相邻角点的坐标差，就可以得到所有角点在世界坐标系下的坐标。 (世界坐标系嘛…人为设定一下就好)","categories":[],"tags":[{"name":"computer vision","slug":"computer-vision","permalink":"http://cjkkkk.github.io/tags/computer-vision/"}]},{"title":"四元数 quaternion","slug":"quaternion","date":"2019-03-13T05:23:13.000Z","updated":"2019-03-14T16:12:39.976Z","comments":true,"path":"2019/03/13/quaternion/","link":"","permalink":"http://cjkkkk.github.io/2019/03/13/quaternion/","excerpt":"","text":"3D旋转公式Rodrigues&#39;s Rotation Formula 3D旋转公式$v^{‘} = cos(\\theta)v + ( 1 - cos(\\theta))(u\\cdot v)u + sin(\\theta)(u\\times v)$ 四元数四元数与复数十分类似， 不同之处为四元数有3个虚部而复数只有1个虚部所有四元数$q \\in H, q = a + bi + cj + dk， i^2 + j^2 = k^2 = ijk = -1$ 向量形式 q = \\left[ \\begin{matrix} a\\\\ b\\\\ c\\\\ d \\end{matrix} \\right] \\tag{4}或者将四元数的实部与虚部分开表示 q = \\left[ \\begin{matrix} s & v \\end{matrix} \\right] \\tag{5} v = \\left[ \\begin{matrix} x\\\\ y\\\\ z \\end{matrix} \\right] \\tag{4}四元数运算加减法/与标量乘法类比向量 乘法不支持交换律 Graßmann Product$q_1 = [s, v] , q_2 = [t, u]$$q_1q_2 = [st - v\\cdot u, su + tv + v\\times u]$ 共轭$q^* = [s, -v]$$qq^* = q^*q = ||q||^2$满足交换律 四元数的逆定义$qq^{-1} = 1$同时左乘$q^*$得$q^*qq^{-1} = q^*$$||q||^2q^{-1} = q^*$$q^{-1} = \\frac{q^*}{||q||^2}$ 用四元数表示旋转设三维点$p = [x, y, z]$, 进行由轴角$n, \\theta$指定的旋转，旋转之后得到的点为$p^r$ 首先将$p$用四元数$ [0, x, y, z]$表示, 用四元数$q = [cos\\frac{\\theta}{2}, nsin\\frac{\\theta}{2}]$表示旋转 则 $p^r = q p q^{-1}$ 表示旋转的方式 四元数(opencv中用以表现旋转) 轴角 $n \\theta$ 旋转矩阵","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"c++ algorithm","slug":"c-algorithm","date":"2019-03-12T16:53:28.000Z","updated":"2019-03-18T08:49:26.794Z","comments":true,"path":"2019/03/13/c-algorithm/","link":"","permalink":"http://cjkkkk.github.io/2019/03/13/c-algorithm/","excerpt":"","text":"为了面试苦学c++ orz… 记录下STL中的algorithm模块 STL三大组件 Iterator algorithm container 核心思想: 数据结构与算法分离，为各种数据结构提供统一的算法。 一些函数algorithm函数列表 all_of/count_if all_of count_if 12345678int main() &#123; // all_of std::vector&lt;int&gt; s = &#123;1, 2, 3, 5&#125;; std::cout &lt;&lt; std::all_of(s.begin(), s.end(), [](int x) &#123; return x &gt; 0;&#125;) &lt;&lt; \"\\n\"; // count_if std::cout &lt;&lt; std::count_if(s.begin(), s.end(), [](int x) &#123; return x &gt; 1;&#125;);&#125; copycopy(iterator s_begin, iterator s_end, iterator t_begin) 123456int main() &#123; std::vector&lt;int&gt; s = &#123;1, 2, 3, 5&#125;; // copy std::vector&lt;int&gt; s2; std::copy(s.begin(), s.end(), std::back_inserter(s2));&#125; for_each/transform for_each transform(iterator t_begin, iterator t_end, iterator s_begin, function) 12345678int main() &#123; std::vector&lt;int&gt; s = &#123;1, 2, 3, 5&#125;; // for_each std::for_each(s.begin(), s.end(), [](int &amp;x) &#123; x = x * x;&#125;); // transform std::transform(s.begin(), s.end(), s.begin(), [](int x) -&gt; int &#123;return x + 1;&#125;);&#125; iter_swapiter_swap(iterator, iterator) sortsort(iterator, iteratot, function) 123456789101112struct Interval &#123; int start; int end; Interval(int a, int b):start(a), end(b)&#123;&#125;&#125;int main()&#123; sort(intervals.begin(), intervals.end(), [](const Interval&amp; x, const Interval&amp; y)&#123; return x.end &lt; y.end; &#125;);&#125;","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://cjkkkk.github.io/tags/c/"}]},{"title":"c++ generic","slug":"generics","date":"2019-03-12T11:42:09.000Z","updated":"2019-03-14T16:29:52.641Z","comments":true,"path":"2019/03/12/generics/","link":"","permalink":"http://cjkkkk.github.io/2019/03/12/generics/","excerpt":"","text":"c++中的模板以函数模板为例1234template&lt;T&gt;T sub(T a, T b)&#123; return a - b;&#125; 函数模板定义了函数的通用公式，减少为不同类型相同功能写重复代码123int sub(int a, int b);float sub(float a, float b);... 编译器如何检查类型以上文中的sub函数为例，如果我们传入不支持减法的类型，编译器能检查出错误吗？比如如果尝试使用1string s = sub(\"AA\", \"BB\"); 我们都知道字符串是不支持减法的(不考虑操作符重载)，那么编译器如何在编译期发现这个错误呢？ 说到底，模板就是一种对重复代码的抽象方式。编译器会在实例化模板时为具体类型的时候进行语法检查，也就是说在调用sub(&quot;AA&quot;, &quot;BB&quot;)的时候，编译器会根据实参的类型string来进行类型检查，也就能发现我们实例化的函数是有语义错误的。 (模板函数不意味着函数需要支持所有可能的类型，使用模板函数不意味着会发生编译器在编译期无法确定的类型错误) 在.cpp文件中定义模板类会发生错误？编译器需要在实例化模板函数的时候可见模板函数的定义(不是声明)，只是声明无法确定需要实例化函数的函数体12//sub.htemplate &lt;typename T&gt; sub(float a, float b); 1234//sub.cpptemplate &lt;typename T&gt; sub(float a, float b)&#123; return a - b;&#125; 12345#include &lt;stdio.h&gt;#include &lt;sub.h&gt;int main()&#123; int d = sub(1, 2); // 需要实例化模板函数&#125; 在sub.h中只能看到声明template &lt;typename T&gt; sub(float a, float b);无法实例化函数，编译器假设其他编译单元中包含sub(int a, int b)的定义，但是找不到定义，所以抛出undefined reference的错误。 解决方法在sub.h中定义模板函数缺点 编译速度缓慢(头文件过大) 无法隐藏代码实现 显式实例化以上文的sub.h 和 sub.cpp为例， 为了阅读方便我再次把两个文件copy下来 12//sub.htemplate &lt;typename T&gt; sub(float a, float b); 1234//sub.cpptemplate &lt;typename T&gt; sub(float a, float b)&#123; return a - b;&#125; 12345#include &lt;stdio.h&gt;#include &lt;sub.h&gt;int main()&#123; int d = sub(1, 2); // 需要实例化模板函数，error&#125; 上文提到实例化sub函数的时候，sub.h中不包含模板函数的定义导致了错误。我们可以想到令其他编译单元(其他.cpp/.obj文件)生成我们需要的实例模板函数。 举例，建立init_sub.cpp文件，我们令这个编译单元生成我们main函数中需要的sub函数123//init_sub.cpp#include \"sub.cpp\"template int sub(int a, int b); 这样init_sub.cpp编译单元中就包含了int sub(int a, int b)main函数就不会报错了。 导出模板使用export关键词1234//sub.cppexport template &lt;typename T&gt; sub(float a, float b)&#123; return a - b;&#125; 但是编译器大多没有实现。 总结头文件定义模板函数适用于小型项目 显示实例化适用于大型项目加速编译 typename vs. class//todo 推荐阅读 模板的编译模型","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://cjkkkk.github.io/tags/c/"}]},{"title":"c++ string","slug":"c-string","date":"2019-03-12T10:24:33.000Z","updated":"2019-03-15T16:07:07.128Z","comments":true,"path":"2019/03/12/c-string/","link":"","permalink":"http://cjkkkk.github.io/2019/03/12/c-string/","excerpt":"","text":"最近准备Google面试，写图形学项目发现自己c++菜的一逼…于是准备记录一些c++的学习笔记orz const char* vs. std::string定义 string 是c++的class,变量内存空间存放字符序列 const char* 只是一个指向存放字符序列的内存区域的指针，变量内存空间只存放指针 拷贝明显可以看出拷贝const char*只需要拷贝指针， 而拷贝string需要复制整个内存区域 互相转换 const char* 可以被隐式转换为 string 从指针指向的地方开始复制字符 string需要使用c_str() 来转换为const char*,同时这意味着失去string中方便的函数 常用操作迭代器 iterator1234std::string s = \"\";for(std::string::iterator it = s.begin(); s!= it.end(); it++)&#123; std::cout &lt;&lt; (*it) &lt;&lt; std::endl;&#125; 子串 slice1std::string sub = s.substr(0,2); 长度 length12std::string s = \"ABB\";std::cout &lt;&lt; s.length() &lt;&lt; std::endl; 求string类型下标为i的字符12s[i]char c=s.at(i) 查找t是否为s的子串1s.find(t); 返回值: 子串的起始下标或者string::npos npos是啥static const size_t npos = -1 而size_t是unsigned，这说明npos是size_t类型变量的最大值 1std::cout &lt;&lt; (std::string::npos == -1) ; // 1","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://cjkkkk.github.io/tags/c/"}]},{"title":"Monte Carlo","slug":"Monte-Carlo","date":"2019-03-11T10:20:12.000Z","updated":"2019-03-14T16:26:50.931Z","comments":true,"path":"2019/03/11/Monte-Carlo/","link":"","permalink":"http://cjkkkk.github.io/2019/03/11/Monte-Carlo/","excerpt":"","text":"什么是Monte Carlo Method简单来说， Monte Carlo Method就是找到函数的期望输出值/函数的积分(原函数不是初等原函数比如${e^{x^2}}$)等问题答案的一系列统计学的方法集合。 Monte Carlo Method的核心就是random sampling, 引用俄罗斯数学家Sobol的话来说: The Monte Carlo method is a numerical method of solving mathematical problems by random sampling (or by the simulation of random variables). Monte Carlo Method主要解决两类问题 模拟 积分 特点随着随机采样sample数目的提高，收敛的速度增加的十分缓慢 蒙特卡洛积分公式$\\frac{1}{N}\\sum{\\frac{f(x_i)}{pdf(x_i)}}$ pdf 是概率分布函数 如何利用平均分布生成非均匀分布的采样参考链接 inverse method// todo rejection method// todo 一些概念概率密度函数 probability density function随机变量的取值落在某个区域内的概率为概率密度函数在这个区域上的积分比如x在(0, 1)之间均匀分布， x的概率密度函数为f(x) = x则x在(0, 0.5)之间的概率为$\\int_{0}^{0.5}xdx = 0.125$ 累积密度函数 cumulative density function就是概率密度函数的积分orz","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"光模拟 Light Simulator","slug":"rendering-of-3D-image-overview","date":"2019-03-10T10:27:45.000Z","updated":"2019-03-29T08:25:17.934Z","comments":true,"path":"2019/03/10/rendering-of-3D-image-overview/","link":"","permalink":"http://cjkkkk.github.io/2019/03/10/rendering-of-3D-image-overview/","excerpt":"","text":"先导光与物体表面的作用 吸收 反射 投射 光在界面的反射和折射是光与物质极化和电子相互作用的结果，才有介电常数和折射率这一说。 分清界面透过率和整体透过率。界面透过率小，反射率就大。通过界面的光，吸收越大，整体透过率就越小。 光的吸收 吸收和物质的能带结构有着直接关系。(能带结构？) 简单来说取决于物体的电子是否易于吸收光子能量进行跃迁，稳定物质如绝缘体/电解质/水等不易吸收。 金属比较特殊，无带隙，电子处于自由态，不存在跃迁的说法，对光的反射很强。 透明程度 首先取决于材质对光的反射率，然后是材质的吸收以及材质内部的结构是否均匀一致 推荐阅读为什么玻璃是透明的，而金属不是？ 如何理解光的反射/透射和吸收 反射与折射折射公式 -&gt; Snell’s law. 入射角度与折射角度的关系 折射与反射比例与角度有关 -&gt; Fresnel’s equation(可由麦克斯韦方程推出) 一般来说在靠近垂直方向观察时候，反射较弱而折射较强 金属的Fresnel效应较弱 绝缘体的Fresnel效应较强 kr为反射系数 kt为折射系数, n为相对折射率(入射与折射角度正弦之比) 折射率与折射系数 物体折射率指的是光在真空中的传播速度与光在该介质中的传播速度之比 折射系数说的是反射光与折射光的比例，总为 1 - 反射率 (反射率的计算参见Fresnel euqation) light effects镜面反射 specular Reflection 光线强弱与视线的角度有关参考链接 漫反射 Diffuse Reflection 效果与视角无关各个方向出射的光强一致 高光 Glossy 既非完全镜面也非完全粗糙 微面 microfacetIn computer graphics we often like to describe rough surfaces, using the image of a surface made of lots of microfacet, where each one of these micro facets is orientated in a slightly different direction and act on its own as a perfect mirror 粗糙程度 roughness仍然是镜面反射，但是物体表面是粗糙的，导致反射方向不一致 子表面射散 Subsurface Scattering 半透明材质 在蜡/用大理石做成的小物体中清晰可见 很薄的有机材料(皮肤 叶子)在用逆强光照射时候也可见 焦散 Caustics柔阴影 soft shadows 与物体表面材质无关 光传输 Light Transport物体的外观由光线如何与物体表面材质发生作用以及光线如何在空间中运动决定light effect可以被分为两种 物体表面如何与光线交互 shading reflection, transparency, specular reflection, diffuse reflection and subsurface scattering design mathematical models that approximate the way light interacts with matter, at a fraction of the time it would take if these interactions where to be physically simulated 物体如何收到光线 light transport indirect diffuse, indirect specular and soft shadows More generally, light transport is interested in the paths light rays are to follow as they travel from a light source to the eye (which we call light paths). what happens in path？ 全局光照 global illumination模拟直接光照与间接关照(物体没有直接收到光源的照射) 只模拟直接光照只需要找到从相机射出的光线与场景中物体的交点， 然后从这些交点向光源射出光线即可(这些光线也叫shadow ray) 间接光照可想而知从交点直接向光源发射光线是不够的，因为存在物体收到的是其他物体反射的光线。 可以重复之前发射光线的方法继续寻找新的交点，直到碰到光源或者重复次数达到一定数目。(极大的计算量，计算量主要都来自于光线与物体求交的计算。) 其他模拟方法包括point cloud based, photon maps, virtual point lights, shadow maps等等。 Radiosity也可以用来计算全局光照，如今使用不多，主要在80 90年代。 problem 产生大量的噪音 Noise 直接使用ray tracing计算间接光照有时候反而导致noise 难以模拟焦散 Caustics 从光源出发才是最自然的 无法从P点得知光线的来源 Blinn’s Law and Moore’s law Moore’s law Blinn’s law how many sencondary rays is needed ? mirror needs 1 ray transport needs 2 rays diffuse needs many rays unidirectional只从eye出发追踪到light source而不从light source出发 bidirectional从eye出发发射光线到光源的同时，从光源逆向光线 shading反射率 albedo物体的颜色显然不是仅仅取决于落到物体上的光照强弱，还与物体本身反射率有关","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"numpy-basic","slug":"numpy-basic","date":"2019-01-08T03:06:09.000Z","updated":"2019-03-11T10:20:49.768Z","comments":true,"path":"2019/01/08/numpy-basic/","link":"","permalink":"http://cjkkkk.github.io/2019/01/08/numpy-basic/","excerpt":"","text":"// todo","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://cjkkkk.github.io/tags/Python/"}]},{"title":"haskell-mind-map","slug":"haskell-knowledge-mind","date":"2019-01-01T15:30:02.000Z","updated":"2019-03-14T16:15:26.076Z","comments":true,"path":"2019/01/01/haskell-knowledge-mind/","link":"","permalink":"http://cjkkkk.github.io/2019/01/01/haskell-knowledge-mind/","excerpt":"","text":"chapter1 重要的概念 Important Concept 函数式 functional 纯净 pure 惰性 lazy 严格类型 statically typed 抽象 abstraction 基本数据类型 basic type Int Integer Double Float Bool Char String 模式匹配 pattern matching 守卫 guards 组 pair 列表 List chapter 2 代数数据类型 Algebraic data type 1234data AlgDataType = Constr1 Type11 Type12 | Constr2 Type21 | Constr3 Type31 Type32 Type33 | Constr4 x@pat 12baz :: Person -&gt; Stringbaz p@(Person n _ _) = &quot;The name field of (&quot; ++ show p ++ &quot;) is &quot; ++ n case 12case \"HELLO\" of _ -&gt; 7 递归数据类型 recursive data types 12data Tree = Leaf Char | Node Tree Int Tree chapter 3 多态 Polymorphism 多态数据 Polymorphic data types 1data List t = E | C t (List t) 多态函数 Polymorphic functions 1filterList :: (t -&gt; Bool) -&gt; List t -&gt; List t 标准库 prelude map / filter /fold Maybe 完整和部分函数 Total and partial functions1head [] -- 抛出错误 无法处理空列表 chapter 4 匿名函数 anoymous functions 1\\x-&gt; x &gt; 100 函数组合 functions composition 1(+3) . (+2) $ 2 科里化 curry 函数只接受一个参数 function arrow 是左结合的 function application 是右结合的 chapter 5 Parametricity type class example 123456789101112class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x /= y = not (x == y)data Foo = F Int | G Charinstance Eq Foo where (F i1) == (F i2) = i1 == i2 (G c1) == (G c2) = c1 == c2 _ == _ = False foo1 /= foo2 = not (foo1 == foo2) common type class Eq Show Ord Num Read Type classes and Java interfaces chapter 6 严格求值 Strict evaluation easy to predit 副作用 side effect time sensitive -&gt; Lazy forces pure 惰性求值 Lazy evaluation when some expression is given as an argument to a function, it is simply packaged up as an unevaluated expression (called a “thunk” 匹配导致求值 Pattern matching drives evaluation Expressions are only evaluated when pattern-matched …only as far as necessary for the match to proceed, and no farther!","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://cjkkkk.github.io/tags/Haskell/"}]},{"title":"how-https-works","slug":"how-https-works","date":"2018-12-31T08:41:33.000Z","updated":"2019-03-14T16:27:20.997Z","comments":true,"path":"2018/12/31/how-https-works/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/how-https-works/","excerpt":"","text":"HTTPS是如何工作的[翻译]原文链接HTTPS is simply your standard HTTP protocol slathered with a generous layer of delicious SSL/TLS encryption goodness.HTTPS其实只是具有SSL / TLS加密优势的标准HTTP协议Unless something goes horribly wrong (and it can), it prevents people like the infamous Eve from viewing or modifying the requests that make up your browsing experience;除非某些事情发生了非常严重的错误(这是有可能发生的),HTTPS协议能保护使用者免于遭受第三人(infamous eve)篡改或者监视你的浏览请求(http request)it’s what keeps your passwords, communications and credit card details safe on the wire between your computer and the servers you want to send this data to.HTTPS是使你的密码，通讯和信用卡信息在你的电脑与你想发送信息的服务器网线之间保持安全的东西。Whilst the little green padlock and the letters “https” in your address bar don’t mean that there isn’t still ample rope for both you and the website you are viewing to hang yourselves elsewhere, they do at least help you communicate securely whilst you do so.同时，在你浏览器地址栏上绿色的小锁和”https”的字样并不一定意味着没有办法欺骗你和你正在访问的网站，但HTTPS协议至少帮助你在与你访问的网站之间通信时能保持安全。 1. What is HTTPS and what does it do?1. HTTPS 是什么以及它的功能HTTPS takes the well-known and understood HTTP protocol, and simply layers a SSL/TLS (hereafter referred to simply as “SSL”) encryption layer on top of it. Servers and clients still speak exactly the same HTTP to each other, but over a secure SSL connection that encrypts and decrypts their requests and responses. The SSL layer has 2 main purposes:HTTPS协议仍然使用众所周知的HTTP协议，只是简单地在其上层叠SSL / TLS（以下简称为“SSL”）加密层。服务器和客户端仍然使用HTTP互相交流，但是是通过一个SSL连接来加密解密通讯的请求与回应。SSL层有两个主要的作用：Verifying that you are talking directly to the server that you think you are talking toEnsuring that only the server can read what you send it and only you can read what it sends back验证你确实是在直接与你想要通讯的服务器通讯。确保只有服务器能读取到你发送的信息，同时只有你能读取到服务器返回的信息。The really, really clever part is that anyone can intercept every single one of the messages you exchange with a server, including the ones where you are agreeing on the key and encryption strategy to use, and still not be able to read any of the actual data you send.这其中最聪明巧妙的部分就是即使所有人都可以拦截你与服务器通讯的每一个请求，甚至包括你与服务器交流使用的加密算法与密钥的请求，他们仍然无法知道你与服务器之间传递的真实数据(actual data)。(译者注:他们可以获取你与服务器的通信内容，却无法解密) 2. How an SSL connection is established2. SSL连接是如何建立的An SSL connection between a client and server is set up by a handshake, the goals of which are:一个服务器与客户端的SSL连接是通过握手(handshake)建立的,握手的目的是: To satisfy the client that it is talking to the right server (and optionally visa versa) 确保客户端正在与正确的服务器通信（反之亦然） For the parties to have agreed on a “cipher suite”, which includes which encryption algorithm they will use to exchange data 各方“密码套件”达成一致，其中包括他们将用于交换数据的加密算法 For the parties to have agreed on any necessary keys for this algorithm 双方就算法中使用到的任何密钥达成一致 Once the connection is established, both parties can use the agreed algorithm and keys to securely send messages to each other. We will break the handshake up into 3 main phases - Hello, Certificate Exchange and Key Exchange.一旦连接成功建立，双方可以使用事先同意使用的算法和密钥来安全的通讯。接下来，我们会将握手(handshake)分成3个主要的阶段 - 打招呼(hello)，证书(certificate)交换，密钥(key)交换Hello - The handshake begins with the client sending a ClientHello message. This contains all the information the server needs in order to connect to the client via SSL, including the various cipher suites and maximum SSL version that it supports. The server responds with a ServerHello, which contains similar information required by the client, including a decision based on the client’s preferences about which cipher suite and version of SSL will be used.打招呼(Hello) - 握手以客户端发送一个问好信息(ClientHello message)开始.这个信息包含了所有服务器需要知道以通过ssl连接客户端的内容，包括”密码套件”和支持的最大SSL版本号。服务器返回一个回复信息(ServerHello)，这其中包括与之前客户端发送的类似的，客户端需要的信息，其中包括关于是否支持客户端使用的SSL和”密码套件”的决定。Certificate Exchange - Now that contact has been established, the server has to prove its identity to the client.This is achieved using its SSL certificate, which is a very tiny bit like its passport. An SSL certificate contains various pieces of data, including the name of the owner, the property (eg. domain) it is attached to, the certificate’s public key, the digital signature and information about the certificate’s validity dates.证书交换 - 现在连接建立之后，服务器必需向客户端证明自己的身份。这是通过使用使用一个非常小的类似于密码的一个称为SSL证书的东西。一个SSL证书包含许多的信息，其中有证书拥有者的名字，证书附着的属性(比如服务器域名),证书的公钥，数字签名以及证书合法时间的信息。The client checks that it either implicitly trusts the certificate, or that it is verified and trusted by one of several Certificate Authorities (CAs) that it also implicitly trusts. Much more about this shortly. Note that the server is also allowed to require a certificate to prove the client’s identity, but this typically only happens in very sensitive applications.客户端检查客户端是否隐式的信任这个证书或者这个证书验证成功且被客户端隐式信任的众多证书机构(CA)之一信任。很快就会有更多这方面的内容。请注意服务器端同样可以要求客户端提供证书来证明客户端的身份，但这一般只在非常机密的应用中发生。Key Exchange - The encryption of the actual message data exchanged by the client and server will be done using a symmetric algorithm, the exact nature of which was already agreed during the Hello phase. A symmetric algorithm uses a single key for both encryption and decryption, in contrast to asymmetric algorithms that require a public/private key pair. Both parties need to agree on this single, symmetric key, a process that is accomplished securely using asymmetric encryption and the server’s public/private keys.密钥交换 - 客户端与服务器交流的数据将会由对称加密算法加密，这在打招呼阶段已经被一致同意。一个对称加密算法使用一个单一的密钥用于加密以及解密，而不对称加密算法需要一对公钥/密钥。双方需要就使用的密钥达成一致，这个过程是通过使用服务器的公/私钥安全的完成的。 The client generates a random key to be used for the main, symmetric algorithm. It encrypts it using an algorithm also agreed upon during the Hello phase, and the server’s public key (found on its SSL certificate).客户端生成随机密钥用于主要的对称加密算法。客户端用之前双方同意的加密算法以及服务器的公钥(SSL证书上附着)来加密随机生成的密钥It sends this encrypted key to the server, where it is decrypted using the server’s private key, and the interesting parts of the handshake are complete.客户端将加密过的密钥发送给服务器，服务器使用私钥进行解密，这样握手就完成了。The parties are sufficiently happy that they are talking to the right person, and have secretly agreed on a key to symmetrically encrypt the data that they are about to send each other.这样双方就可以确认自己确实与正确的对象通讯，并且就用于对称加密双方通信数据的公钥达成一致。HTTP requests and responses can now be sent by forming a plaintext message and then encrypting and sending it. The other party is the only one who knows how to decrypt this message, and so Man In The Middle Attackers are unable to read or modify any requests that they may intercept.现在HTTP请求与响应可以使用明文信息构造，并用密钥加密后进行发送。而对方则是唯一知道如何解密的人，这样一来”中间人攻击”就无法修改或者读取它拦截的信息。 3. Certificates3. 证书3.1 Trust3.1 信任At its most basic level, an SSL certificate is simply a text file, and anyone with a text editor can create one. You can in fact trivially create a certificate claiming that you are Google Inc. and that you control the domain gmail.com.在最基本的层面上，SSL证书只是一个文本文件，所有拥有一个文本编辑器的人都可以创建它。实际上，你可以轻松创建一个声明你是Google Inc.并且你控制gmail.com这个域名的证书。If this were the whole story then SSL would be a joke; identity verification would essentially be the client asking the server “are you Google?”, the server replying “er, yeah totally, here’s a piece of paper with ‘I am Google’ written on it” and the client saying “OK great, here’s all my data.” The magic that prevents this farce is in the digital signature, which allows a party to verify that another party’s piece of paper really is legit.如果这是整个故事，那么SSL将是一个笑话; 身份验证基本上是客户端询问服务器“你是谷歌吗？”，服务器回答“呃，是的，这是一张纸，上面写着’我是谷歌’”，客户说“好的，这里是我所有的数据。“防止这场闹剧的神奇之处在于数字签名，它允许一方确认另一方的纸张确实是合法的。There are 2 sensible reasons why you might trust a certificate: If it’s on a list of certificates that you trust implicitlyIf it’s able to prove that it is trusted by the controller of one of the certificates on the above list 您可能因为两个明智的理由信任证书： 如果它位于您隐含信任的证书列表中如果它能够证明上述列表中的一个证书的控制器信任它 The first criteria is easy to check. Your browser has a pre-installed list of trusted SSL certificates from Certificate Authorities (CAs) that you can view, add and remove from.第一个标准很容易检查。 您的浏览器具有预安装的证书颁发机构（CA）证书列表，您可以查看，添加和删除。These certificates are controlled by a centralised group of (in theory, and generally in practice) extremely secure, reliable and trustworthy organisations like Symantec, Comodo and GoDaddy.这些证书由一组（理论上和通常在实践中）极其安全，可靠和值得信赖的组织（如Symantec，Comodo和GoDaddy）控制。If a server presents a certificate from that list then you know you can trust them.如果服务器提供该列表中的证书，那么您知道可以信任它们。The second criteria is much harder. It’s easy for a server to say “er yeah, my name is er, Microsoft, you trust Symantec and er, they totally trust me, so it’s all cool.” A somewhat smart client might then go and ask Symantec “I’ve got a Microsoft here who say that you trust them, is this true?” But even if Symantec say “yep, we know them, Microsoft are legit”, you still don’t know whether the server claiming to be Microsoft actually is Microsoft or something much worse. This is where digital signatures come in.第二个标准要困难得多。 服务器很容易说”是的，我的名字是，微软，你信任Symantec，他们完全信任我，所以这没有任何问题。”一个有点聪明的客户端可能会去问Symantec：”我有一个微软在这里说你信任他们，这是真的吗？”但即使Symantec说:”是的，我们知道他们，微软是合法的”，你仍然不知道声称是微软的服务器实际上是微软还是其他东西更糟糕。这就是数字签名的用武之地。 3.2 Digital signatures3.2 数字签名As already noted, SSL certificates have an associated public/private key pair.如前所述，SSL证书具有与其关联的公钥/私钥对。The public key is distributed as part of the certificate, and the private key is kept incredibly safely guarded. This pair of asymmetric keys is used in the SSL handshake to exchange a further key for both parties to symmetrically encrypt and decrypt data.公钥作为证书的一部分进行分发，而私钥被保密得非常安全。 这对非对称密钥用于SSL握手，以便为双方交换另一密钥以对称地加密和解密数据。The client uses the server’s public key to encrypt the symmetric key and send it securely to the server, and the server uses its private key to decrypt it.客户端使用服务器的公钥加密对称密钥并将其安全地发送到服务器，服务器使用其私钥对其进行解密。Anyone can encrypt using the public key, but only the server can decrypt using the private key.任何人都可以使用公钥加密，但只有服务器可以使用私钥解密。The opposite is true for a digital signature. A certificate can be “signed” by another authority, whereby the authority effectively goes on record as saying “we have verified that the controller of this certificate also controls the property (domain) listed on the certificate”.数字签名的情况恰恰相反。 证书可以由另一个机构”签名”，由此权威机构有效地记录为”我们已经验证该证书的控制者还控制证书上列出的属性（域名）。In this case the authority uses their private key to (broadly speaking) encrypt the contents of the certificate, and this cipher text is attached to the certificate as its digital signature.在这种情况下，权威机构使用其私钥（广泛地说）加密证书的内容，并且该密文作为其数字签名附加到证书。Anyone can decrypt this signature using the authority’s public key, and verify that it results in the expected decrypted value.任何人都可以使用权威机构的公钥解密此签名，并验证它是否会产生预期的解密值。But only the authority can encrypt content using the private key, and so only the authority can actually create a valid signature in the first place.但只有权威机构可以使用私钥加密内容，因此只有权威机构才能实际创建有效的签名。(回到上面4句可以看到二者为什么相反)So if a server comes along claiming to have a certificate for Microsoft.com that is signed by Symantec (or some other CA), your browser doesn’t have to take its word for it.因此，如果服务器声称拥有由Symantec（或其他某些CA）签名的Microsoft.com证书，您的浏览器不必相信。If it is legit, Symantec will have used their (ultra-secret) private key to generate the server’s SSL certificate’s digital signature, and so your browser use can use their (ultra-public) public key to check that this signature is valid.如果它是合法的，Symantec将使用他们的（超秘密）私钥生成服务器的SSL证书的数字签名，因此您的浏览器使用可以使用他们的（超公开）公钥来检查此签名是否有效。Symantec will have taken steps to ensure the organisation they are signing for really does own Microsoft.com, and so given that your client trusts Symantec, it can be sure that it really is talking to Microsoft Inc.Symantec将采取措施确保他们签署的组织确实拥有Microsoft.com，因此，鉴于您的客户端信任Symantec，可以肯定它确实与微软公司谈判。 总计: CA的私钥与服务器端的私钥是保证安全性的重要关键CA保证了证书只能由它们签发，服务器保证客户端发来的信息只能由它们解密。 3.3 Self-signing3.3 自签发Note that all root CA certificates are “self-signed”, meaning that the digital signature is generated using the certificate’s own private key.请注意，所有根CA证书都是“自签名”，这意味着使用证书自己的私钥生成数字签名。There’s nothing intrinsically special about a root CA’s certificate - you can generate your own self-signed certificate and use this to sign other certificates if you want.根CA的证书没有任何本质上的特殊之处 - 您可以生成自己的自签名证书，并根据需要使用它来签署其他证书。 But since your random certificate is not pre-loaded as a CA into any browsers anywhere, none of them will trust you to sign either your own or other certificates.但由于您的随机证书未在任何浏览器中作为CA预先加载到任何浏览器中，因此他们都不会信任您签署自己的证书或其他证书。You are effectively saying “er yeah, I’m totally Microsoft, here’s an official certificate of identity issued and signed by myself,” and all properly functioning browsers will throw up a very scary error message in response to your dodgy credentials.你实际上是在说“呃，是的，我完全是微软，这是我自己发布和签署的官方身份证明”，所有正常运行的浏览器都会抛出一个非常可怕的错误信息，以回应你的狡猾凭据。This puts an enormous burden on all browser and OS publishers to trust only squeaky clean root CAs, as these are the organisations that their users end up trusting to vet websites and keep certificates safe. This is not an easy task.这给所有浏览器和操作系统发布者带来了巨大负担，只能信任干净的干净根CA，因为这些组织的用户最终信任它们来审查网站并保证证书安全。这不是一件容易的事。 3.4 What are you trusting?3.4 你相信什么?It’s interesting to note that your client is technically not trying to verify whether or not it should trust the party that sent it a certificate, but whether it should trust the public key contained in the certificate.有趣的是，您的客户端在技术上并未尝试验证它是否应该信任发送证书的一方，而是它是否应该信任证书中包含的公钥。SSL certificates are completely open and public, so any attacker could grab Microsoft’s certificate, intercept a client’s request to Microsoft.com and present the legitimate certificate to it.SSL证书是完全开放和公开的，因此任何攻击者都可以获取Microsoft的证书，拦截客户对Microsoft.com的请求并向其提供合法证书。The client would accept this and happily begin the handshake. However, when the client encrypts the key that will be used for actual data encryption, it will do so using the real Microsoft’s public key from this real certificate.客户会接受这一点并愉快地开始握手。 但是，当客户端加密将用于实际数据加密的密钥时，它将使用此真实证书中的真实Microsoft公钥进行加密。Since the attacker doesn’t have Microsoft’s private key in order to decrypt it, they are now stuck. Even if the handshake is completed, they will still not be able to decrypt the key, and so will not be able to decrypt any of the data that the client sends to them.由于攻击者没有Microsoft的私钥来解密它，因此它们现在被卡住了。 即使握手完成，它们仍然无法解密密钥，因此无法解密客户端发送给它们的任何数据。Order is maintained as long as the attacker doesn’t control a trusted certificate’s private key. If the client is somehow tricked into trusting a certificate and public key whose private key is controlled by an attacker, trouble begins.只要攻击者无法控制受信任证书的私钥，秩序就不会发生混乱。 如果客户端以某种方式欺骗信任其私钥由攻击者控制的证书和公钥，则麻烦就开始了。","categories":[],"tags":[{"name":"Network Basic","slug":"Network-Basic","permalink":"http://cjkkkk.github.io/tags/Network-Basic/"}]},{"title":"backend-end-101","slug":"backend-101","date":"2018-12-31T08:33:34.000Z","updated":"2019-03-14T16:29:16.402Z","comments":true,"path":"2018/12/31/backend-101/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/backend-101/","excerpt":"","text":"后端1011 聊一下什么是后端后端的主要作用就是处理并响应前端发来的请求一个例子:前端: 查看一下当前用户列表，并告诉我男女比后端: 从数据库中查找用户列表，并计算男女比，将结果返回 问题: 前端如何发送请求到后端 后端如何解析请求 … 1.1 谈一下网络请求网络请求本质上就是发送方准备好了一堆01这样的二进制数据，然后通过你家的网线传输了出去，在中间各种路由器/交换机/服务器转发后到达了接收方的手中。 例子这个发送方可以是你的浏览器，当你在Chrome的地址栏敲下 http://www.baidu.com并按下回车的时候，你的浏览器首先发送了一个请求到DNS服务器查询了这个域名对应的ip(DNS的原理大家动手查查)。然后它尝试与这个ip指向的服务器建立一个TCP连接(TCP的3次握手，4次挥手大家再动手查查)，建立了TCP连接之后呢，你的浏览器发送了一个http请求。 百度的服务器接受到这个http请求之后，将需要显示给你的HTML文本放在了一个http响应中，返回给你。浏览器接收到这个响应之后，拿出了HTML文本后，根据需要可能还会请求CSS/JS/图片等等资源，请求形式和之前浏览器请求http://www.baidu.com类似,这次可能请求的是http://www.baidu.com/css/index.css。最后浏览器解析出了一个你看到的百度网页的样子。 什么是TCP连接/什么是http请求？我们接下来看看OSI 7层协议 tcp握手讲解 1.2 OSI 7层协议 啥是协议?协议是经过合作各方同意的一个统一标准同理网络协议就是一个经过商讨后得出的规定网络之间如何进行通信的标准 什么是OSI 7层协议OSI 7层协议是一个比较抽象的模型，(因为实际上数据包就是一堆二进制代码，没有层这个概念)，但它的核心思想很具体。就是规定网络传输过程中数据包的二进制数据的格式/内容以及传输方式。 而之所以分成7层是因为需要将每一个通信模块分离，每一个通信模块之间只提供接口，而不关心内部的实现，以这种方式进行设计，只要接口没变，内部的实现方式可以随意改变，使得每一个通信模块可以独立设计，也可以很方便的利用其他模块提供的接口进行新的模块设计。 除了物理层外从上往下每一层都会在原有的数据包上加上特定的帧头(就是包含特定信息的二进制数据) 比如网络层帧头，其中包含了目的地网络地址，用于指示沿途的路由器，这一串二进制流的目的地是哪里，路由器查询自己的网络地址表，决定再发给更靠近目的地的下一跳路由器。 之前提到的HTTP协议/DNS协议就是一个位于应用层的协议，而TCP协议则是位于传输层的一个协议。HTTP协议主要是确定了发送的数据包的内容应该是什么样的格式，而TCP协议主要是帮助你进行一个可靠的传输。 可想而知由应用程序发出的一个网络请求沿着应用层向下每层都添加了特定的帧头，最后形成一个完整的请求包。 http请求就是使用http协议的一个网络请求。 什么叫使用http协议呢？接下来关注一下传输层及其以上的部分 2 关注一下传输层及其以上的部分2.1 我们为啥需要在TCP协议之上建立HTTP等协议?其实吧, 抛开HTTP协议, TCP连接也可以很好的工作, 我们也可以愉快的传输数据。但是我们传输的数据没有一个统一的标准,即大家应该如何来解析你发来的数据呢?你发送了一堆二进制,它确实是数据,但接受方假如不知道如何解析你发来的数据,他就无法知道是按照UTF-8编码模式来解析你的请求,还是当作一堆数字,还是说你想传递的是一张图片呢?我们不得而知, 这堆数据不能叫信息,而是垃圾。通信中的双方似乎讲的不是一种语言。 2.2 HTTP协议来了所以吧 我们就想在TCP协议之上写一个应用层协议来告诉通信中的双方应该如何解析发送来的数据，也就有了HTTP这一些的协议 2.3 补充一下你不仅可以建立在TCP协议之上 你还可以建立在UDP等其他协议上(传输层协议不只有TCP，还有比如UDP，DNS协议就是建立在UDP协议之上的) 2.4 那我们自定义协议写一个简单的客户端与服务端吧好吧,既然如此那就让我们来看一个建立在TCP协议之上的一个自定义协议的服务端和客户端, 我叫它NP协议吧(naive protocol) 2.5 我们要先知道下socket在TCP连接中有两个端点,都用主机的IP地址加上主机上的端口号作为端点的表示，而我们通常将这种端点就叫做套接字（socket）。它是TCP连接中端的抽象，是操作系统提供的操作协议栈的一种接口。 其实socket也提供了建立在UDP协议上的接口(但这都是后话了)我们利用socket可以在TCP协议上直接发送数据，或者说定义一个新的协议。 2.6 一个自定义协议的例子例子使用c语言包含一个客户端与服务端，两者基于socket自定义协议通信代码见内训资料贴压缩包 3 HTTP 那把刚才的自定义协议换成HTTP协议就是我们经常在用的HTTP server的协议基础啦~你们常用的ftp server就是把自定义协议 换成ftp协议啦还有其他的一些协议大家自己了解下吧(DNS/SSH/HTTPS/…) HTTP协议长什么样呢？简单来说HTTP协议HTTP 协议入门 3.1 一个简单的HTTP服务假设大家装好了python3那么尝试在一个目录下运行1python -m http.server -p 8000 然后打开8000端口 3.2 用Node.js的http模块写一个简单的服务器12345678910111213141516171819202122const http = require('http')const port = 3000const requestHandler = (request, response) =&gt; &#123; console.log(request.url) if(request.url === \"/hello\")&#123; response.end('in /hello') &#125;else if(request.url === \"/user\")&#123; response.end('in /user') &#125;else&#123; response.end('Hello Node.js Server!') &#125;&#125;const server = http.createServer(requestHandler)server.listen(port, (err) =&gt; &#123; if (err) &#123; return console.log('something bad happened', err) &#125; console.log(`server is listening on $&#123;port&#125;`)&#125;)","categories":[],"tags":[{"name":"learning material","slug":"learning-material","permalink":"http://cjkkkk.github.io/tags/learning-material/"}]},{"title":"front-end-101","slug":"front-end-101","date":"2018-12-31T08:31:33.000Z","updated":"2019-03-14T16:29:03.696Z","comments":true,"path":"2018/12/31/front-end-101/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/front-end-101/","excerpt":"","text":"前端1010 前端概览前端 html / css / js / resource / ….html 描述了网页的骨架/结构css 描述了网页的表现形式/模样js 给网页更多的可能, 动态操作dom/AJAX请求/改变样式/动画/… 前端历史 1 HTML基础HTML的发展历史参考链接 1.1 HTML是什么 HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) HTML 使用标记标签来描述网页1.2 HTML基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 保存为index.html，然后用浏览器打开这个文件就可以看到你写的html文件的展示效果 HTML中就是使用标签来描述网页的结构,如&lt;p&gt;内容&lt;/p&gt;这是一个表示网页段落的标签。 标签需要闭合,有的标签需要开始标签与结束标签，如&lt;p&gt;内容&lt;/p&gt; 而有的标签是自闭合的, 如&lt;br/&gt; lab:打开index.html观察效果DOCTYPE html的作用？ 1.3 常用的标签1234567&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;a&gt;&lt;/a&gt;&lt;br/&gt;&lt;div&gt;&lt;/div&gt;&lt;input/&gt;&lt;img/&gt; 1.4 标签的属性1.4.1 属性是什么1&lt;img src=\"xxxxx\"/&gt; 标签可以用于属性，用来描述标签的性质比如上面的src属性可以用来表示img标签中显示图片的地址 1.4.2 一些例子123&lt;div style=\"background:black;width:100px\"&gt; hello world&lt;/div&gt; style属性描述了div标签的表现形式，通俗的说就是描述了div标签在页面中张什么样子。可以试着改变100这个值为其他东西，比如600，或者更改black为red。观察效果如何。这将与我们之后提到的css有关 1.4.3 class/id 你可以通过给标签添加class属性给你的标签分组 你可以通过给标签添加id属性给你的标签加唯一的身份标识有什么用呢？针对某些特定的标签做一些事情的时候 举例 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color:red; &#125; .green &#123; color:green; &#125; #yellow &#123; color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p class=\"red\"&gt;我的第1个段落。&lt;/p&gt; &lt;p class=\"green\"&gt;我的第2个段落。&lt;/p&gt; &lt;p class=\"red\"&gt;我的第3个段落。&lt;/p&gt; &lt;p class=\"green\"&gt;我的第4个段落。&lt;/p&gt; &lt;p class=\"red\"&gt;我的第5个段落。&lt;/p&gt; &lt;p id=\"yellow\"&gt;我的第6个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; lab:打开classId.html请观察这些标签的效果，试着做一些改变看看会发生什么 1.4.4 自定义属性你还可以自定义属性123&lt;div data-blah=\"blah\"&gt; hello world&lt;/div&gt; 这样你可以添加自己对标签的一些额外的描述 1.5 HTML注释1&lt;!-- 在此处写注释 --&gt; example123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;!-- &lt;p&gt;我的第一个段落。&lt;/p&gt;--&gt; &lt;/body&gt;&lt;/html&gt; lab:打开comment.html观察效果观察上述代码的结果 1.6 HTML链接1.6.1 认识&lt;a&gt;&lt;/a&gt;标签1&lt;a href=\"www.baidu.com\"&gt;Link text&lt;/a&gt; lab:试着在之前的a.html点击这个链接，观察发生了什么 1.6.2 页面内跳转1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; height:200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#7th\"&gt;go to 7th p&lt;/a&gt; &lt;a href=\"#8th\"&gt;go to 8th p&lt;/a&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第1个段落。&lt;/p&gt; &lt;p&gt;我的第2个段落。&lt;/p&gt; &lt;p&gt;我的第3个段落。&lt;/p&gt; &lt;p&gt;我的第4个段落。&lt;/p&gt; &lt;p&gt;我的第5个段落。&lt;/p&gt; &lt;p&gt;我的第6个段落。&lt;/p&gt; &lt;a name=\"7th\"&gt;我的第7个段落。&lt;/a&gt; &lt;p id=\"8th\"&gt;我的第8个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; lab:打开anchor.html观察效果 1.7 HTML的头部常用的头部标签1234&lt;title&gt; 页面title&lt;/title&gt; &lt;meta&gt; 设置页面的元数据 比如使用的编码&lt;link&gt;&lt;script&gt;&lt;/script&gt; HTML headnote:关注链接中的相关链接部分 1.8 更多标签-&gt;w3cschoolMDN请关注表单控件/表格 1.10 行内元素和块级元素参考链接Note：关注常见的行内元素/块级元素关注行内元素与块级元素的区别lab:打开blockInline.html观察效果尝试给span元素增加高度设置 1.11 Chrome开发者工具的简单用法2 css基础 有了html你可以很好表达你的页面中需要有什么，你可以说我的页面里需要有一个我的自拍照。 这很妙，可是你无法很好的表达你的页面中的元素应该长什么样子，比如你的照片多大，放在哪里，加个滤镜？ 又比如这段文字的大小，颜色应该是什么样的？ 其实我们在这之前就已经接触到了css(style属性/style标签) 但我们需要一个更好的表达我们页面样式的方式来做到更好的复用性/与我们的html分离2.1 css是什么层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。 2.2 css基础语法1234selectorlist &#123; property: value; [more property:value; pairs]&#125; 1234567strong &#123; color: red;&#125;div.menu-bar li:hover &gt; ul &#123; display: block;&#125; 2.3 css选择器如何写selectorlist选择器Note:关注 简单选择器(元素/class/id选择) 属性选择器 伪类和伪元素 组合器 2.4 css伪类伪类 2.5 css伪元素伪类 2.4 css注释/**/1234.exciting-text::after &#123;/* content: \"&lt;- 让人兴兴兴奋!\"; */ color: green; &#125; 2.5 css优先级继承和优先级优先级取决于1 重要性（Importance） ！important优先2 专用性（Specificity） 详细的优先3 源代码次序（Source order） 后面的战胜之前的 继承规则决定后代元素是否继承祖先元素的某些属性值 2.6 盒模型盒模型Note:content（页面的主要内容）padding (分隔页面与边框的距离)border(边框大小)margin (分离与其他元素)关注 box-sizingbox-sizing 2.7 css布局(position/flex/grid)兼容性 position &gt; flex &gt; grid简易度 grid = flex &gt; position 2.7.1 positionposition (MDN)Note: position:static/relative/absoulte/fixed/sticky 注意absoulte定位 If there is no such parent, it will default all the way back up to the \\ element itself meaning it will be placed relatively to the page itself. 注意文档流的概念 lab:打开position文件夹下的html文件观察效果 2.7.2 flexflex (css-tricks的一篇文章)css-trick有许多比较好的css文章Note flex-basis(在其他元素分配剩余空间之前设定默认尺寸) 2.7.3 grid(补充)grid (css-tricks的一篇文章) 2.7.4 float定位(补充)lab:打开 float.html查看效果 2.7.5 高度塌缩(补充)高度塌缩问题 2.7.6 position 和flex冲突吗(补充)position 和flex冲突吗 2.8 css prefix2.8.1 为什么需要前缀？参考链接 试验一些还未成为标准的的CSS属性——也许永远不会成为标准 对新出现的标准的CSS3属性特征做实验性的实现 对CSS3中一些新属性做等效语义的个性实现 Android: -webkit-Chrome: -webkit-Safari: -webkit-iOS: -webkit-Firefox: -moz-Internet Explorer: -ms-Opera: -o- 2.8.2 如何加前缀？autoprefix工具 lab:打开prefix.css并将其中内容复制到autoprefix工具中查看结果 2.9 css预处理(stylus/sass/less…)预处理器的好处以及简单的对比stylus如何使用？","categories":[],"tags":[{"name":"learning material","slug":"learning-material","permalink":"http://cjkkkk.github.io/tags/learning-material/"}]},{"title":"javascript-arrow-function","slug":"javascript-arrow-function","date":"2018-12-31T07:34:08.000Z","updated":"2019-03-14T16:27:43.570Z","comments":true,"path":"2018/12/31/javascript-arrow-function/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-arrow-function/","excerpt":"","text":"1 前言请先看 -&gt; 如何理解this关键词 ES6中引入了一种无法使用4种this绑定规则的特殊函数类型,箭头函数(arrow function)箭头函数根据外层作用域来决定this(有词法作用域的味道) 2 例子看下面的两个例子 example #112345678910function x()&#123; this.a = 3//利用obj调用时候 this指向obj function y()&#123; this.a = 2//this指向全局对象了 &#125; y()&#125;var obj = &#123;&#125;x.apply(obj)console.log(obj,global.a)//&#123;a:3&#125; 2 可以看到上面函数x中的y函数的this指向的是全局对象，因为y的调用使用默认绑定改进方法如下 example #21234567891011function x()&#123; this.a = 3//利用obj调用时候 this指向obj that = this function y()&#123; that.a = 2//利用js闭包的特性记住了外部的this &#125; y()&#125;var obj = &#123;&#125;x.apply(obj)console.log(obj,global.a)//&#123;a:2&#125; undefined 3 更加优雅的箭头函数的方法example #312345678910function x()&#123; this.a = 3//利用obj调用时候 this指向obj var y = () =&gt;&#123;//不修改this this仍然指向obj this.a = 2 &#125; y()&#125;var obj = &#123;a:0&#125;x.apply(obj)console.log(obj)//&#123;a:2&#125; 这里箭头函数y中this是其词法作用域中的this，即x绑定的obj对象。箭头函数的绑定无法被更改，其this在函数定义的时候确定。常用于回调函数中 example 412345678function foo()&#123; setTimeout(function()&#123; console.log(this.a) &#125;,1000)&#125;obj = &#123;a:1&#125;foo.call(obj) // undefined 因为this绑定到全局对象上了 使用箭头函数进行改进 example 512345678function foo()&#123; setTimeout(()=&gt;&#123; console.log(this.a) &#125;,1000)&#125;obj = &#123;a:1&#125;foo.call(obj)//1 这里箭头函数记住了this为foo函数的this，所以调用了obj中的a属性 总结 ： 箭头函数不会采用四条标准的绑定规则，而是根据当前的词法作用域来决定this","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"javascript-prototype","slug":"javascript-prototype","date":"2018-12-31T07:28:14.000Z","updated":"2019-03-14T16:28:05.940Z","comments":true,"path":"2018/12/31/javascript-prototype/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-prototype/","excerpt":"","text":"1 前言javascript 是具有基于原型链的面向对象编程语言 oop != class oop 也不需要基于class 请先抛弃class关键词 2 在javascript中,对象来自于对象Object comes from Object。你可以使用对象来直接构造一个对象example #1123456var food = &#123; eat:\"i eat !\"&#125;var meal = Object.create(food)console.log(meal.eat) // \"i eat\" 现在我来解释下这里发生了什么,首先Object.create(source)方法创建了一个新的空对象,然后将新对象的原型设置为source即你传入对象。 2.1 首先来验证下meal确实是空对象console.log(meal) // {} 2.2 然后我们来验证meal的原型确实是foodmeal.__proto__ === food //true 2.3 你可能会问:等等!__proto__是什么？？？ 为什么meal.eat 输出了内容？？？2.3.1 先回答第一个问题:__proto__是什么？在javascript中所有的对象中都有一个内置属性__proto__,指向它的原型对象。在这个例子中meal的原型对象就是food所有对象的原型指向形成了链式结构，这就是原型链，而原型链的顶端就是Object.prototype meal.__proto -&gt;food food.__proto-&gt;Object.prototype Object.prototype的原型是null Object.prototype.__proto__ -&gt; null 知道这个原理之后我们就可以来模拟一下Object.create() example#21234567891011function ourNew(source)&#123; var obj = &#123;&#125; obj.__proto__ = source return obj&#125;var food = &#123; eat:\"i eat\"&#125;var meal = ourNew(food)console.log(meal.eat)//\"i eat\" 太棒了，我们模拟了一个对象的继承 2.3.2 再回答第二个问题:为什么meal.eat 输出了内容？js中对象属性的查找机制，是从对象本身开始查找，如果查找不到，则顺着原型链继续向上查找，直到找到对应属性后返回，否则返回undefined 即meal.__proto__.__proto__... 当原型链中存在相同属性时候,最先找到的会被返回，而上层的同名属性会被屏蔽 example #3123456789var food = &#123; eat:\"i eat !\"&#125;var meal = Object.create(food)console.log(meal.eat)//\"i eat\"meal.eat = \"i don't eat\"console.log(meal.eat)//\"i don't eat\"console.log(meal.__proto__.eat)//\"i eat\" oops! food的eat属性被meal屏蔽了 3 构造函数 new 关键词在js中我们还可以通过一类特殊的对象 — 函数 来构建对象，也就是我们经常说的构造函数。任何函数只要前面加上关键词new就会被当作是构造函数 example #41234567function Point(x,y)&#123; this.x = x this.y = y&#125;var point = new Point(1,2)console.log(point)//&#123;x:1,y:2&#125; 这其中发生了什么呢？ 1 首先一个对象被创建，对象的_proto_是Point.prototype即构造函数.prototype 2 将this绑定到这个对象，用参数构造这个对象，即 新创建对象的x 变为传入参数 x，新创建对象的y 变为传入参数的 y 3 如果构造函数没有显式返回一个对象，则返回新创建的对象 example #512345678function Point(x,y)&#123; this.x = x this.y = y return &#123;x:100,y:100&#125;//显式返回对象 覆盖新建立的对象&#125;var point = new Point(1,2)console.log(point)//&#123;x:100,y:100&#125; 所以在js中对象直接来自对象，不管你是用object.create() 还是 new function()来创建","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"javascript-this","slug":"javascript-this","date":"2018-12-31T07:18:09.000Z","updated":"2019-03-14T16:28:15.675Z","comments":true,"path":"2018/12/31/javascript-this/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-this/","excerpt":"","text":"1 前言：this 是javascript中一个重要的关键词 根据函数执行时候上下文的不同this代表的含义也不同 2 为什么使用thisthis提供了优雅的方式来隐式的传递一个对象的引用 this是在运行时候绑定的，并不是在编写的时候绑定的，它的上下文取决于函数调用时的条件。 this绑定规则有4种3 绑定机制3.1 不带任何修饰的函数调用 -默认绑定没有任何修饰，即没有使用apply/call，也没有显式的对象包含 比如 object.somefunction() 12345678a = 1function fun()&#123; console.log(this.a)&#125;fun()//使用默认绑定，非严格模式下是全局对象 window，//调用window的a属性,即1；严格模式下为undefined，发生错误 3.2 隐式绑定被对象拥有或者包含时候使用隐式绑定，this指向调用对象 12345678910let a = 2function fun()&#123; console.log(this.a)&#125;const obj = &#123; a:1, fun:fun&#125;obj.fun()//1 但此时需要注意一种隐式丢失的情况 1234567891011let a = 2function fun()&#123; console.log(this.a)&#125;const obj = &#123; a:1, fun:fun&#125;let anotherfun = obj.funanotherfun()//2,anotherfun是fun的别名或者说引用，此时没有任何修饰,使用默认绑定 对象属性引用链中只有最后一条会影响调用12345678910111213141516function foo()&#123; console.log(this.a)&#125;let obj2 = &#123; a:42, foo:foo&#125;let obj1 = &#123; a:2, obj2:obj2&#125;obj1.obj2.foo()//42 3.3 显示绑定使用call/apply/bind进行硬绑定123456789101112function foo()&#123; console.log(this.a)&#125;obj=&#123; a:1&#125;foo.call(obj) // 1foo.apply(obj) // 1let foo_with_obj = foo.bind(obj)foo_with_obj()//1 3.4 new关键词绑定new的执行过程1 创建一个全新的对象2 绑定原型链3 新对象绑定到函数调用的this4 函数没有返回其他对象，那么返回新对象 可以看到第3步中，new关键词，会将新对象绑定到调用函数的this上 4 绑定的优先级new &gt; 显示 &gt; 隐式 &gt; 默认 证明 显式 &gt; 隐式 123456789101112131415161718function foo()&#123; console.log(this.a)&#125;obj1= &#123; a:1, foo:foo&#125;obj2=&#123; a:2, foo:foo&#125;obj1.foo()//1obj2.foo()//2obj1.foo.call(obj2)//2obj2.foo.call(obj1)//1 证明 new优先级高于显示绑定123456789101112function foo(something)&#123; this.a= something&#125;let obj = &#123;&#125;let bar = foo.bind(obj)bar(2)console.log(obj.a)//2let baz = new bar(3)console.log(obj.a)//2console.log(baz.a)//3 5 apply/call/bind 使用 null作为绑定对象此时为默认绑定如果你的函数不会修改this，那么可以放心传入否则，你的函数会在全局对象上产生可怕的修改12345678910function foo(x)&#123; this.x = x&#125;let obj = &#123;&#125;foo.apply(obj, [2])console.log(obj.x)//2foo.apply(null, [3])console.log(global.x)// 2 3 5.1 避免不必要的默认绑定可以使用一个空的DMZ对象进行绑定12345function foo()&#123; this.a = 1&#125;valet SPECIAL_OBJ = Object.create(null)//空对象&#123;&#125;foo.call(SPECIAL_OBJ)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-30T08:31:33.000Z","updated":"2019-03-14T16:28:47.390Z","comments":true,"path":"2018/12/30/hello-world/","link":"","permalink":"http://cjkkkk.github.io/2018/12/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}