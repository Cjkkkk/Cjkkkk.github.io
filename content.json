{"meta":{"title":"Cjkkkk","subtitle":null,"description":null,"author":"Cjkkkk","url":"http://cjkkkk.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-10T12:08:59.000Z","updated":"2019-03-10T12:09:41.816Z","comments":true,"path":"about/index.html","permalink":"http://cjkkkk.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Monte Carlo","slug":"Monte-Carlo","date":"2019-03-11T10:20:12.000Z","updated":"2019-03-11T12:16:59.151Z","comments":true,"path":"2019/03/11/Monte-Carlo/","link":"","permalink":"http://cjkkkk.github.io/2019/03/11/Monte-Carlo/","excerpt":"","text":"什么是Monte Carlo Method简单来说， Monte Carlo Method就是找到函数的期望输出值/函数的积分(原函数不是初等原函数比如${e^{x^2}}$)等问题答案的一系列统计学的方法集合。 Monte Carlo Method的核心就是random sampling, 引用俄罗斯数学家Sobol的话来说: The Monte Carlo method is a numerical method of solving mathematical problems by random sampling (or by the simulation of random variables). Monte Carlo Method主要解决两类问题 模拟 积分 特点随着随机采样sample数目的提高，收敛的速度增加的十分缓慢 蒙特卡洛积分公式$\\frac{1}{N}\\sum{\\frac{f(x_i)}{pdf(x_i)}}$ pdf 是概率分布函数 生成非均匀分布的采样假设$x = f()$生成均匀的(0, 1)的分布 则$y = x^2$生成不均匀的(0, 1)的分布，因为当x在0-0.5之间的概率是0.5，说明$y = x^2$在0-0.25的概率是0.5在0.25-0.75之间的概率是0.5 概率密度函数 probability density function随机变量的取值落在某个区域内的概率为概率密度函数在这个区域上的积分比如x在(0, 1)之间均匀分布， x的概率密度函数为f(x) = 1则x在(0, 0.5)之间的概率为$\\int_{0}^{0.5}1dx = 0.5 - 0 = 0.5$","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"光线模拟 Light Simulator","slug":"rendering-of-3D-image-overview","date":"2019-03-10T10:27:45.000Z","updated":"2019-03-11T10:18:31.972Z","comments":true,"path":"2019/03/10/rendering-of-3D-image-overview/","link":"","permalink":"http://cjkkkk.github.io/2019/03/10/rendering-of-3D-image-overview/","excerpt":"","text":"light effects反射 Reflection view-dependent 高光 Glossy perfectly reflective (like a mirror) nor perfectly diffuse 微面 microfacetIn computer graphics we often like to describe rough surfaces, using the image of a surface made of lots of microfacet, where each one of these micro facets is orientated in a slightly different direction and act on its own as a perfect mirror 粗糙程度 roughness仍然是镜面反射，但是物体表面是粗糙的，导致反射方向不一致 漫反射 Diffuse Reflection view-independentWhen we talked about specular reflection, we mentioned that light rays were scattered around the mirror direction. But for diffuse surfaces, rays are scattered even more, in fact so much,that they are reflected in all sort of random directions 透明 Transparency refract Snell’s law. How much light is being reflected vs refracted is given by the Fresnel’s equation 子表面射散 Subsurface Scattering Translucent surfaces in a way are surfaces which are not completely opaque nor completely transparent The effect is clearly visible when wax, a small object made out of jade or marble, or when a thin layer of organic material (skin, leaves) is strongly illuminated from the back 焦散 Caustics柔阴影 soft shadows 与物体表面材质无关 Light TransportThe appearance of objects, only depends on the way light interacts with matter and travels trough space light effect可以被分为两种 物体表面如何与光线交互 shading reflection, transparency, specular reflection, diffuse reflection and subsurface scattering design mathematical models that approximate the way light interacts with matter, at a fraction of the time it would take if these interactions where to be physically simulated 物体如何收到光线 light transport indirect diffuse, indirect specular and soft shadows More generally, light transport is interested in the paths light rays are to follow as they travel from a light source to the eye (which we call light paths). what happens in path？ 全局光照 global illumination模拟直接光照与间接关照 只模拟直接光照With direct lighting you only need to find the intersection between the primary or camera or eye rays (the rays traced from the camera) and the geometry in the scene, and then cast a ray from each one of these intersections to the lights in the scene (this ray is called a shadow ray) 间接光照Many alternative to ray tracing for simulating indirect lighting exist (point cloud based, photon maps, virtual point lights, shadow maps, etc.Radiosity is another method to compute global illumination. It’s not very much used anymore these days but was very popular in the 80s early 90s); problem 产生大量的噪音 Noise 直接使用ray tracing计算间接光照有时候反而导致noise 难以模拟焦散 Caustics 从光源出发才是最自然的 无法从P点得知光线的来源 Blinn’s Law and Moore’s law Moore’s law Blinn’s law how many sencondary rays is needed ? mirror needs 1 ray transport needs 2 rays diffuse needs many rays unidirectional只从eye出发追踪到light source而不从light source出发 bidirectional从eye出发发射光线到光源的同时，从光源逆向光线 shading反射率 albedo物体的颜色显然不是仅仅取决于落到物体上的光照强弱，还与物体本身反射率有关","categories":[],"tags":[{"name":"Computer Graphics","slug":"Computer-Graphics","permalink":"http://cjkkkk.github.io/tags/Computer-Graphics/"}]},{"title":"numpy-basic","slug":"numpy-basic","date":"2019-01-08T03:06:09.000Z","updated":"2019-03-11T10:20:49.768Z","comments":true,"path":"2019/01/08/numpy-basic/","link":"","permalink":"http://cjkkkk.github.io/2019/01/08/numpy-basic/","excerpt":"","text":"// todo","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://cjkkkk.github.io/tags/Python/"}]},{"title":"haskell-mind-map","slug":"haskell-knowledge-mind","date":"2019-01-01T15:30:02.000Z","updated":"2019-03-11T05:03:20.073Z","comments":true,"path":"2019/01/01/haskell-knowledge-mind/","link":"","permalink":"http://cjkkkk.github.io/2019/01/01/haskell-knowledge-mind/","excerpt":"","text":"chapter1 重要的概念 Important Concept 函数式 functional 纯净 pure 惰性 lazy 严格类型 statically typed 抽象 abstraction 基本数据类型 basic type Int Integer Double Float Bool Char String 模式匹配 pattern matching 守卫 guards 组 pair 列表 List chapter 2 代数数据类型 Algebraic data type 1234data AlgDataType = Constr1 Type11 Type12 | Constr2 Type21 | Constr3 Type31 Type32 Type33 | Constr4 x@pat 12baz :: Person -&gt; Stringbaz p@(Person n _ _) = &quot;The name field of (&quot; ++ show p ++ &quot;) is &quot; ++ n case 12case \"HELLO\" of _ -&gt; 7 递归数据类型 recursive data types 12data Tree = Leaf Char | Node Tree Int Tree chapter 3 多态 Polymorphism 多态数据 Polymorphic data types 1data List t = E | C t (List t) 多态函数 Polymorphic functions 1filterList :: (t -&gt; Bool) -&gt; List t -&gt; List t 标准库 prelude map / filter /fold Maybe 完整和部分函数 Total and partial functions1head [] -- 抛出错误 无法处理空列表 chapter 4 匿名函数 anoymous functions 1\\x-&gt; x &gt; 100 函数组合 functions composition 1(+3) . (+2) $ 2 科里化 curry 函数只接受一个参数 function arrow 是左结合的 function application 是右结合的 chapter 5 Parametricity type class example 123456789101112class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x /= y = not (x == y)data Foo = F Int | G Charinstance Eq Foo where (F i1) == (F i2) = i1 == i2 (G c1) == (G c2) = c1 == c2 _ == _ = False foo1 /= foo2 = not (foo1 == foo2) common type class Eq Show Ord Num Read Type classes and Java interfaces chapter 6 严格求值 Strict evaluation easy to predit 副作用 side effect time sensitive -&gt; Lazy forces pure 惰性求值 Lazy evaluation when some expression is given as an argument to a function, it is simply packaged up as an unevaluated expression (called a “thunk” 匹配导致求值 Pattern matching drives evaluation Expressions are only evaluated when pattern-matched …only as far as necessary for the match to proceed, and no farther!","categories":[],"tags":[{"name":"Haskell","slug":"Haskell","permalink":"http://cjkkkk.github.io/tags/Haskell/"}]},{"title":"how-https-works","slug":"how-https-works","date":"2018-12-31T08:41:33.000Z","updated":"2018-12-31T08:43:54.243Z","comments":true,"path":"2018/12/31/how-https-works/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/how-https-works/","excerpt":"","text":"HTTPS是如何工作的[翻译]原文链接HTTPS is simply your standard HTTP protocol slathered with a generous layer of delicious SSL/TLS encryption goodness.HTTPS其实只是具有SSL / TLS加密优势的标准HTTP协议Unless something goes horribly wrong (and it can), it prevents people like the infamous Eve from viewing or modifying the requests that make up your browsing experience;除非某些事情发生了非常严重的错误(这是有可能发生的),HTTPS协议能保护使用者免于遭受第三人(infamous eve)篡改或者监视你的浏览请求(http request)it’s what keeps your passwords, communications and credit card details safe on the wire between your computer and the servers you want to send this data to.HTTPS是使你的密码，通讯和信用卡信息在你的电脑与你想发送信息的服务器网线之间保持安全的东西。Whilst the little green padlock and the letters “https” in your address bar don’t mean that there isn’t still ample rope for both you and the website you are viewing to hang yourselves elsewhere, they do at least help you communicate securely whilst you do so.同时，在你浏览器地址栏上绿色的小锁和”https”的字样并不一定意味着没有办法欺骗你和你正在访问的网站，但HTTPS协议至少帮助你在与你访问的网站之间通信时能保持安全。 1. What is HTTPS and what does it do?1. HTTPS 是什么以及它的功能HTTPS takes the well-known and understood HTTP protocol, and simply layers a SSL/TLS (hereafter referred to simply as “SSL”) encryption layer on top of it. Servers and clients still speak exactly the same HTTP to each other, but over a secure SSL connection that encrypts and decrypts their requests and responses. The SSL layer has 2 main purposes:HTTPS协议仍然使用众所周知的HTTP协议，只是简单地在其上层叠SSL / TLS（以下简称为“SSL”）加密层。服务器和客户端仍然使用HTTP互相交流，但是是通过一个SSL连接来加密解密通讯的请求与回应。SSL层有两个主要的作用：Verifying that you are talking directly to the server that you think you are talking toEnsuring that only the server can read what you send it and only you can read what it sends back验证你确实是在直接与你想要通讯的服务器通讯。确保只有服务器能读取到你发送的信息，同时只有你能读取到服务器返回的信息。The really, really clever part is that anyone can intercept every single one of the messages you exchange with a server, including the ones where you are agreeing on the key and encryption strategy to use, and still not be able to read any of the actual data you send.这其中最聪明巧妙的部分就是即使所有人都可以拦截你与服务器通讯的每一个请求，甚至包括你与服务器交流使用的加密算法与密钥的请求，他们仍然无法知道你与服务器之间传递的真实数据(actual data)。(译者注:他们可以获取你与服务器的通信内容，却无法解密) 2. How an SSL connection is established2. SSL连接是如何建立的An SSL connection between a client and server is set up by a handshake, the goals of which are:一个服务器与客户端的SSL连接是通过握手(handshake)建立的,握手的目的是: To satisfy the client that it is talking to the right server (and optionally visa versa) 确保客户端正在与正确的服务器通信（反之亦然） For the parties to have agreed on a “cipher suite”, which includes which encryption algorithm they will use to exchange data 各方“密码套件”达成一致，其中包括他们将用于交换数据的加密算法 For the parties to have agreed on any necessary keys for this algorithm 双方就算法中使用到的任何密钥达成一致 Once the connection is established, both parties can use the agreed algorithm and keys to securely send messages to each other. We will break the handshake up into 3 main phases - Hello, Certificate Exchange and Key Exchange.一旦连接成功建立，双方可以使用事先同意使用的算法和密钥来安全的通讯。接下来，我们会将握手(handshake)分成3个主要的阶段 - 打招呼(hello)，证书(certificate)交换，密钥(key)交换Hello - The handshake begins with the client sending a ClientHello message. This contains all the information the server needs in order to connect to the client via SSL, including the various cipher suites and maximum SSL version that it supports. The server responds with a ServerHello, which contains similar information required by the client, including a decision based on the client’s preferences about which cipher suite and version of SSL will be used.打招呼(Hello) - 握手以客户端发送一个问好信息(ClientHello message)开始.这个信息包含了所有服务器需要知道以通过ssl连接客户端的内容，包括”密码套件”和支持的最大SSL版本号。服务器返回一个回复信息(ServerHello)，这其中包括与之前客户端发送的类似的，客户端需要的信息，其中包括关于是否支持客户端使用的SSL和”密码套件”的决定。Certificate Exchange - Now that contact has been established, the server has to prove its identity to the client.This is achieved using its SSL certificate, which is a very tiny bit like its passport. An SSL certificate contains various pieces of data, including the name of the owner, the property (eg. domain) it is attached to, the certificate’s public key, the digital signature and information about the certificate’s validity dates.证书交换 - 现在连接建立之后，服务器必需向客户端证明自己的身份。这是通过使用使用一个非常小的类似于密码的一个称为SSL证书的东西。一个SSL证书包含许多的信息，其中有证书拥有者的名字，证书附着的属性(比如服务器域名),证书的公钥，数字签名以及证书合法时间的信息。The client checks that it either implicitly trusts the certificate, or that it is verified and trusted by one of several Certificate Authorities (CAs) that it also implicitly trusts. Much more about this shortly. Note that the server is also allowed to require a certificate to prove the client’s identity, but this typically only happens in very sensitive applications.客户端检查客户端是否隐式的信任这个证书或者这个证书验证成功且被客户端隐式信任的众多证书机构(CA)之一信任。很快就会有更多这方面的内容。请注意服务器端同样可以要求客户端提供证书来证明客户端的身份，但这一般只在非常机密的应用中发生。Key Exchange - The encryption of the actual message data exchanged by the client and server will be done using a symmetric algorithm, the exact nature of which was already agreed during the Hello phase. A symmetric algorithm uses a single key for both encryption and decryption, in contrast to asymmetric algorithms that require a public/private key pair. Both parties need to agree on this single, symmetric key, a process that is accomplished securely using asymmetric encryption and the server’s public/private keys.密钥交换 - 客户端与服务器交流的数据将会由对称加密算法加密，这在打招呼阶段已经被一致同意。一个对称加密算法使用一个单一的密钥用于加密以及解密，而不对称加密算法需要一对公钥/密钥。双方需要就使用的密钥达成一致，这个过程是通过使用服务器的公/私钥安全的完成的。 The client generates a random key to be used for the main, symmetric algorithm. It encrypts it using an algorithm also agreed upon during the Hello phase, and the server’s public key (found on its SSL certificate).客户端生成随机密钥用于主要的对称加密算法。客户端用之前双方同意的加密算法以及服务器的公钥(SSL证书上附着)来加密随机生成的密钥It sends this encrypted key to the server, where it is decrypted using the server’s private key, and the interesting parts of the handshake are complete.客户端将加密过的密钥发送给服务器，服务器使用私钥进行解密，这样握手就完成了。The parties are sufficiently happy that they are talking to the right person, and have secretly agreed on a key to symmetrically encrypt the data that they are about to send each other.这样双方就可以确认自己确实与正确的对象通讯，并且就用于对称加密双方通信数据的公钥达成一致。HTTP requests and responses can now be sent by forming a plaintext message and then encrypting and sending it. The other party is the only one who knows how to decrypt this message, and so Man In The Middle Attackers are unable to read or modify any requests that they may intercept.现在HTTP请求与响应可以使用明文信息构造，并用密钥加密后进行发送。而对方则是唯一知道如何解密的人，这样一来”中间人攻击”就无法修改或者读取它拦截的信息。 3. Certificates3. 证书3.1 Trust3.1 信任At its most basic level, an SSL certificate is simply a text file, and anyone with a text editor can create one. You can in fact trivially create a certificate claiming that you are Google Inc. and that you control the domain gmail.com.在最基本的层面上，SSL证书只是一个文本文件，所有拥有一个文本编辑器的人都可以创建它。实际上，你可以轻松创建一个声明你是Google Inc.并且你控制gmail.com这个域名的证书。If this were the whole story then SSL would be a joke; identity verification would essentially be the client asking the server “are you Google?”, the server replying “er, yeah totally, here’s a piece of paper with ‘I am Google’ written on it” and the client saying “OK great, here’s all my data.” The magic that prevents this farce is in the digital signature, which allows a party to verify that another party’s piece of paper really is legit.如果这是整个故事，那么SSL将是一个笑话; 身份验证基本上是客户端询问服务器“你是谷歌吗？”，服务器回答“呃，是的，这是一张纸，上面写着’我是谷歌’”，客户说“好的，这里是我所有的数据。“防止这场闹剧的神奇之处在于数字签名，它允许一方确认另一方的纸张确实是合法的。There are 2 sensible reasons why you might trust a certificate: If it’s on a list of certificates that you trust implicitlyIf it’s able to prove that it is trusted by the controller of one of the certificates on the above list 您可能因为两个明智的理由信任证书： 如果它位于您隐含信任的证书列表中如果它能够证明上述列表中的一个证书的控制器信任它 The first criteria is easy to check. Your browser has a pre-installed list of trusted SSL certificates from Certificate Authorities (CAs) that you can view, add and remove from.第一个标准很容易检查。 您的浏览器具有预安装的证书颁发机构（CA）证书列表，您可以查看，添加和删除。These certificates are controlled by a centralised group of (in theory, and generally in practice) extremely secure, reliable and trustworthy organisations like Symantec, Comodo and GoDaddy.这些证书由一组（理论上和通常在实践中）极其安全，可靠和值得信赖的组织（如Symantec，Comodo和GoDaddy）控制。If a server presents a certificate from that list then you know you can trust them.如果服务器提供该列表中的证书，那么您知道可以信任它们。The second criteria is much harder. It’s easy for a server to say “er yeah, my name is er, Microsoft, you trust Symantec and er, they totally trust me, so it’s all cool.” A somewhat smart client might then go and ask Symantec “I’ve got a Microsoft here who say that you trust them, is this true?” But even if Symantec say “yep, we know them, Microsoft are legit”, you still don’t know whether the server claiming to be Microsoft actually is Microsoft or something much worse. This is where digital signatures come in.第二个标准要困难得多。 服务器很容易说”是的，我的名字是，微软，你信任Symantec，他们完全信任我，所以这没有任何问题。”一个有点聪明的客户端可能会去问Symantec：”我有一个微软在这里说你信任他们，这是真的吗？”但即使Symantec说:”是的，我们知道他们，微软是合法的”，你仍然不知道声称是微软的服务器实际上是微软还是其他东西更糟糕。这就是数字签名的用武之地。 3.2 Digital signatures3.2 数字签名As already noted, SSL certificates have an associated public/private key pair.如前所述，SSL证书具有与其关联的公钥/私钥对。The public key is distributed as part of the certificate, and the private key is kept incredibly safely guarded. This pair of asymmetric keys is used in the SSL handshake to exchange a further key for both parties to symmetrically encrypt and decrypt data.公钥作为证书的一部分进行分发，而私钥被保密得非常安全。 这对非对称密钥用于SSL握手，以便为双方交换另一密钥以对称地加密和解密数据。The client uses the server’s public key to encrypt the symmetric key and send it securely to the server, and the server uses its private key to decrypt it.客户端使用服务器的公钥加密对称密钥并将其安全地发送到服务器，服务器使用其私钥对其进行解密。Anyone can encrypt using the public key, but only the server can decrypt using the private key.任何人都可以使用公钥加密，但只有服务器可以使用私钥解密。The opposite is true for a digital signature. A certificate can be “signed” by another authority, whereby the authority effectively goes on record as saying “we have verified that the controller of this certificate also controls the property (domain) listed on the certificate”.数字签名的情况恰恰相反。 证书可以由另一个机构”签名”，由此权威机构有效地记录为”我们已经验证该证书的控制者还控制证书上列出的属性（域名）。In this case the authority uses their private key to (broadly speaking) encrypt the contents of the certificate, and this cipher text is attached to the certificate as its digital signature.在这种情况下，权威机构使用其私钥（广泛地说）加密证书的内容，并且该密文作为其数字签名附加到证书。Anyone can decrypt this signature using the authority’s public key, and verify that it results in the expected decrypted value.任何人都可以使用权威机构的公钥解密此签名，并验证它是否会产生预期的解密值。But only the authority can encrypt content using the private key, and so only the authority can actually create a valid signature in the first place.但只有权威机构可以使用私钥加密内容，因此只有权威机构才能实际创建有效的签名。(回到上面4句可以看到二者为什么相反)So if a server comes along claiming to have a certificate for Microsoft.com that is signed by Symantec (or some other CA), your browser doesn’t have to take its word for it.因此，如果服务器声称拥有由Symantec（或其他某些CA）签名的Microsoft.com证书，您的浏览器不必相信。If it is legit, Symantec will have used their (ultra-secret) private key to generate the server’s SSL certificate’s digital signature, and so your browser use can use their (ultra-public) public key to check that this signature is valid.如果它是合法的，Symantec将使用他们的（超秘密）私钥生成服务器的SSL证书的数字签名，因此您的浏览器使用可以使用他们的（超公开）公钥来检查此签名是否有效。Symantec will have taken steps to ensure the organisation they are signing for really does own Microsoft.com, and so given that your client trusts Symantec, it can be sure that it really is talking to Microsoft Inc.Symantec将采取措施确保他们签署的组织确实拥有Microsoft.com，因此，鉴于您的客户端信任Symantec，可以肯定它确实与微软公司谈判。 总计: CA的私钥与服务器端的私钥是保证安全性的重要关键CA保证了证书只能由它们签发，服务器保证客户端发来的信息只能由它们解密。 3.3 Self-signing3.3 自签发Note that all root CA certificates are “self-signed”, meaning that the digital signature is generated using the certificate’s own private key.请注意，所有根CA证书都是“自签名”，这意味着使用证书自己的私钥生成数字签名。There’s nothing intrinsically special about a root CA’s certificate - you can generate your own self-signed certificate and use this to sign other certificates if you want.根CA的证书没有任何本质上的特殊之处 - 您可以生成自己的自签名证书，并根据需要使用它来签署其他证书。 But since your random certificate is not pre-loaded as a CA into any browsers anywhere, none of them will trust you to sign either your own or other certificates.但由于您的随机证书未在任何浏览器中作为CA预先加载到任何浏览器中，因此他们都不会信任您签署自己的证书或其他证书。You are effectively saying “er yeah, I’m totally Microsoft, here’s an official certificate of identity issued and signed by myself,” and all properly functioning browsers will throw up a very scary error message in response to your dodgy credentials.你实际上是在说“呃，是的，我完全是微软，这是我自己发布和签署的官方身份证明”，所有正常运行的浏览器都会抛出一个非常可怕的错误信息，以回应你的狡猾凭据。This puts an enormous burden on all browser and OS publishers to trust only squeaky clean root CAs, as these are the organisations that their users end up trusting to vet websites and keep certificates safe. This is not an easy task.这给所有浏览器和操作系统发布者带来了巨大负担，只能信任干净的干净根CA，因为这些组织的用户最终信任它们来审查网站并保证证书安全。这不是一件容易的事。 3.4 What are you trusting?3.4 你相信什么?It’s interesting to note that your client is technically not trying to verify whether or not it should trust the party that sent it a certificate, but whether it should trust the public key contained in the certificate.有趣的是，您的客户端在技术上并未尝试验证它是否应该信任发送证书的一方，而是它是否应该信任证书中包含的公钥。SSL certificates are completely open and public, so any attacker could grab Microsoft’s certificate, intercept a client’s request to Microsoft.com and present the legitimate certificate to it.SSL证书是完全开放和公开的，因此任何攻击者都可以获取Microsoft的证书，拦截客户对Microsoft.com的请求并向其提供合法证书。The client would accept this and happily begin the handshake. However, when the client encrypts the key that will be used for actual data encryption, it will do so using the real Microsoft’s public key from this real certificate.客户会接受这一点并愉快地开始握手。 但是，当客户端加密将用于实际数据加密的密钥时，它将使用此真实证书中的真实Microsoft公钥进行加密。Since the attacker doesn’t have Microsoft’s private key in order to decrypt it, they are now stuck. Even if the handshake is completed, they will still not be able to decrypt the key, and so will not be able to decrypt any of the data that the client sends to them.由于攻击者没有Microsoft的私钥来解密它，因此它们现在被卡住了。 即使握手完成，它们仍然无法解密密钥，因此无法解密客户端发送给它们的任何数据。Order is maintained as long as the attacker doesn’t control a trusted certificate’s private key. If the client is somehow tricked into trusting a certificate and public key whose private key is controlled by an attacker, trouble begins.只要攻击者无法控制受信任证书的私钥，秩序就不会发生混乱。 如果客户端以某种方式欺骗信任其私钥由攻击者控制的证书和公钥，则麻烦就开始了。","categories":[],"tags":[{"name":"Network Basic","slug":"Network-Basic","permalink":"http://cjkkkk.github.io/tags/Network-Basic/"}]},{"title":"backend-end-101","slug":"backend-101","date":"2018-12-31T08:33:34.000Z","updated":"2019-03-10T11:33:15.126Z","comments":true,"path":"2018/12/31/backend-101/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/backend-101/","excerpt":"","text":"后端1011 聊一下什么是后端后端的主要作用就是处理并响应前端发来的请求一个例子:前端: 查看一下当前用户列表，并告诉我男女比后端: 从数据库中查找用户列表，并计算男女比，将结果返回 问题: 前端如何发送请求到后端 后端如何解析请求 … 1.1 谈一下网络请求网络请求本质上就是发送方准备好了一堆01这样的二进制数据，然后通过你家的网线传输了出去，在中间各种路由器/交换机/服务器转发后到达了接收方的手中。 例子这个发送方可以是你的浏览器，当你在Chrome的地址栏敲下 http://www.baidu.com并按下回车的时候，你的浏览器首先发送了一个请求到DNS服务器查询了这个域名对应的ip(DNS的原理大家动手查查)。然后它尝试与这个ip指向的服务器建立一个TCP连接(TCP的3次握手，4次挥手大家再动手查查)，建立了TCP连接之后呢，你的浏览器发送了一个http请求。 百度的服务器接受到这个http请求之后，将需要显示给你的HTML文本放在了一个http响应中，返回给你。浏览器接收到这个响应之后，拿出了HTML文本后，根据需要可能还会请求CSS/JS/图片等等资源，请求形式和之前浏览器请求http://www.baidu.com类似,这次可能请求的是http://www.baidu.com/css/index.css。最后浏览器解析出了一个你看到的百度网页的样子。 什么是TCP连接/什么是http请求？我们接下来看看OSI 7层协议 tcp握手讲解 1.2 OSI 7层协议 啥是协议?协议是经过合作各方同意的一个统一标准同理网络协议就是一个经过商讨后得出的规定网络之间如何进行通信的标准 什么是OSI 7层协议OSI 7层协议是一个比较抽象的模型，(因为实际上数据包就是一堆二进制代码，没有层这个概念)，但它的核心思想很具体。就是规定网络传输过程中数据包的二进制数据的格式/内容以及传输方式。 而之所以分成7层是因为需要将每一个通信模块分离，每一个通信模块之间只提供接口，而不关心内部的实现，以这种方式进行设计，只要接口没变，内部的实现方式可以随意改变，使得每一个通信模块可以独立设计，也可以很方便的利用其他模块提供的接口进行新的模块设计。 除了物理层外从上往下每一层都会在原有的数据包上加上特定的帧头(就是包含特定信息的二进制数据) 比如网络层帧头，其中包含了目的地网络地址，用于指示沿途的路由器，这一串二进制流的目的地是哪里，路由器查询自己的网络地址表，决定再发给更靠近目的地的下一跳路由器。 之前提到的HTTP协议/DNS协议就是一个位于应用层的协议，而TCP协议则是位于传输层的一个协议。HTTP协议主要是确定了发送的数据包的内容应该是什么样的格式，而TCP协议主要是帮助你进行一个可靠的传输。 可想而知由应用程序发出的一个网络请求沿着应用层向下每层都添加了特定的帧头，最后形成一个完整的请求包。 http请求就是使用http协议的一个网络请求。 什么叫使用http协议呢？接下来关注一下传输层及其以上的部分 2 关注一下传输层及其以上的部分2.1 我们为啥需要在TCP协议之上建立HTTP等协议?其实吧, 抛开HTTP协议, TCP连接也可以很好的工作, 我们也可以愉快的传输数据。但是我们传输的数据没有一个统一的标准,即大家应该如何来解析你发来的数据呢?你发送了一堆二进制,它确实是数据,但接受方假如不知道如何解析你发来的数据,他就无法知道是按照UTF-8编码模式来解析你的请求,还是当作一堆数字,还是说你想传递的是一张图片呢?我们不得而知, 这堆数据不能叫信息,而是垃圾。通信中的双方似乎讲的不是一种语言。 2.2 HTTP协议来了所以吧 我们就想在TCP协议之上写一个应用层协议来告诉通信中的双方应该如何解析发送来的数据，也就有了HTTP这一些的协议 2.3 补充一下你不仅可以建立在TCP协议之上 你还可以建立在UDP等其他协议上(传输层协议不只有TCP，还有比如UDP，DNS协议就是建立在UDP协议之上的) 2.4 那我们自定义协议写一个简单的客户端与服务端吧好吧,既然如此那就让我们来看一个建立在TCP协议之上的一个自定义协议的服务端和客户端, 我叫它NP协议吧(naive protocol) 2.5 我们要先知道下socket在TCP连接中有两个端点,都用主机的IP地址加上主机上的端口号作为端点的表示，而我们通常将这种端点就叫做套接字（socket）。它是TCP连接中端的抽象，是操作系统提供的操作协议栈的一种接口。 其实socket也提供了建立在UDP协议上的接口(但这都是后话了)我们利用socket可以在TCP协议上直接发送数据，或者说定义一个新的协议。 2.6 一个自定义协议的例子例子使用c语言包含一个客户端与服务端，两者基于socket自定义协议通信代码见内训资料贴压缩包 3 HTTP 那把刚才的自定义协议换成HTTP协议就是我们经常在用的HTTP server的协议基础啦~你们常用的ftp server就是把自定义协议 换成ftp协议啦还有其他的一些协议大家自己了解下吧(DNS/SSH/HTTPS/…) HTTP协议长什么样呢？简单来说HTTP协议HTTP 协议入门 3.1 一个简单的HTTP服务假设大家装好了python3那么尝试在一个目录下运行1python -m http.server -p 8000 然后打开8000端口 3.2 用Node.js的http模块写一个简单的服务器12345678910111213141516171819202122const http = require('http')const port = 3000const requestHandler = (request, response) =&gt; &#123; console.log(request.url) if(request.url === \"/hello\")&#123; response.end('in /hello') &#125;else if(request.url === \"/user\")&#123; response.end('in /user') &#125;else&#123; response.end('Hello Node.js Server!') &#125;&#125;const server = http.createServer(requestHandler)server.listen(port, (err) =&gt; &#123; if (err) &#123; return console.log('something bad happened', err) &#125; console.log(`server is listening on $&#123;port&#125;`)&#125;)","categories":[],"tags":[{"name":"learning material","slug":"learning-material","permalink":"http://cjkkkk.github.io/tags/learning-material/"}]},{"title":"front-end-101","slug":"front-end-101","date":"2018-12-31T08:31:33.000Z","updated":"2018-12-31T08:32:11.533Z","comments":true,"path":"2018/12/31/front-end-101/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/front-end-101/","excerpt":"","text":"前端1010 前端概览前端 html / css / js / resource / ….html 描述了网页的骨架/结构css 描述了网页的表现形式/模样js 给网页更多的可能, 动态操作dom/AJAX请求/改变样式/动画/… 前端历史 1 HTML基础HTML的发展历史参考链接 1.1 HTML是什么 HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) HTML 使用标记标签来描述网页1.2 HTML基本结构1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"theme.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 保存为index.html，然后用浏览器打开这个文件就可以看到你写的html文件的展示效果 HTML中就是使用标签来描述网页的结构,如&lt;p&gt;内容&lt;/p&gt;这是一个表示网页段落的标签。 标签需要闭合,有的标签需要开始标签与结束标签，如&lt;p&gt;内容&lt;/p&gt; 而有的标签是自闭合的, 如&lt;br/&gt; lab:打开index.html观察效果DOCTYPE html的作用？ 1.3 常用的标签1234567&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt;&lt;a&gt;&lt;/a&gt;&lt;br/&gt;&lt;div&gt;&lt;/div&gt;&lt;input/&gt;&lt;img/&gt; 1.4 标签的属性1.4.1 属性是什么1&lt;img src=\"xxxxx\"/&gt; 标签可以用于属性，用来描述标签的性质比如上面的src属性可以用来表示img标签中显示图片的地址 1.4.2 一些例子123&lt;div style=\"background:black;width:100px\"&gt; hello world&lt;/div&gt; style属性描述了div标签的表现形式，通俗的说就是描述了div标签在页面中张什么样子。可以试着改变100这个值为其他东西，比如600，或者更改black为red。观察效果如何。这将与我们之后提到的css有关 1.4.3 class/id 你可以通过给标签添加class属性给你的标签分组 你可以通过给标签添加id属性给你的标签加唯一的身份标识有什么用呢？针对某些特定的标签做一些事情的时候 举例 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .red &#123; color:red; &#125; .green &#123; color:green; &#125; #yellow &#123; color:yellow; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p class=\"red\"&gt;我的第1个段落。&lt;/p&gt; &lt;p class=\"green\"&gt;我的第2个段落。&lt;/p&gt; &lt;p class=\"red\"&gt;我的第3个段落。&lt;/p&gt; &lt;p class=\"green\"&gt;我的第4个段落。&lt;/p&gt; &lt;p class=\"red\"&gt;我的第5个段落。&lt;/p&gt; &lt;p id=\"yellow\"&gt;我的第6个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; lab:打开classId.html请观察这些标签的效果，试着做一些改变看看会发生什么 1.4.4 自定义属性你还可以自定义属性123&lt;div data-blah=\"blah\"&gt; hello world&lt;/div&gt; 这样你可以添加自己对标签的一些额外的描述 1.5 HTML注释1&lt;!-- 在此处写注释 --&gt; example123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;!-- &lt;p&gt;我的第一个段落。&lt;/p&gt;--&gt; &lt;/body&gt;&lt;/html&gt; lab:打开comment.html观察效果观察上述代码的结果 1.6 HTML链接1.6.1 认识&lt;a&gt;&lt;/a&gt;标签1&lt;a href=\"www.baidu.com\"&gt;Link text&lt;/a&gt; lab:试着在之前的a.html点击这个链接，观察发生了什么 1.6.2 页面内跳转1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; p &#123; height:200px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#7th\"&gt;go to 7th p&lt;/a&gt; &lt;a href=\"#8th\"&gt;go to 8th p&lt;/a&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第1个段落。&lt;/p&gt; &lt;p&gt;我的第2个段落。&lt;/p&gt; &lt;p&gt;我的第3个段落。&lt;/p&gt; &lt;p&gt;我的第4个段落。&lt;/p&gt; &lt;p&gt;我的第5个段落。&lt;/p&gt; &lt;p&gt;我的第6个段落。&lt;/p&gt; &lt;a name=\"7th\"&gt;我的第7个段落。&lt;/a&gt; &lt;p id=\"8th\"&gt;我的第8个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; lab:打开anchor.html观察效果 1.7 HTML的头部常用的头部标签1234&lt;title&gt; 页面title&lt;/title&gt; &lt;meta&gt; 设置页面的元数据 比如使用的编码&lt;link&gt;&lt;script&gt;&lt;/script&gt; HTML headnote:关注链接中的相关链接部分 1.8 更多标签-&gt;w3cschoolMDN请关注表单控件/表格 1.10 行内元素和块级元素参考链接Note：关注常见的行内元素/块级元素关注行内元素与块级元素的区别lab:打开blockInline.html观察效果尝试给span元素增加高度设置 1.11 Chrome开发者工具的简单用法2 css基础 有了html你可以很好表达你的页面中需要有什么，你可以说我的页面里需要有一个我的自拍照。 这很妙，可是你无法很好的表达你的页面中的元素应该长什么样子，比如你的照片多大，放在哪里，加个滤镜？ 又比如这段文字的大小，颜色应该是什么样的？ 其实我们在这之前就已经接触到了css(style属性/style标签) 但我们需要一个更好的表达我们页面样式的方式来做到更好的复用性/与我们的html分离2.1 css是什么层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。 2.2 css基础语法1234selectorlist &#123; property: value; [more property:value; pairs]&#125; 1234567strong &#123; color: red;&#125;div.menu-bar li:hover &gt; ul &#123; display: block;&#125; 2.3 css选择器如何写selectorlist选择器Note:关注 简单选择器(元素/class/id选择) 属性选择器 伪类和伪元素 组合器 2.4 css伪类伪类 2.5 css伪元素伪类 2.4 css注释/**/1234.exciting-text::after &#123;/* content: \"&lt;- 让人兴兴兴奋!\"; */ color: green; &#125; 2.5 css优先级继承和优先级优先级取决于1 重要性（Importance） ！important优先2 专用性（Specificity） 详细的优先3 源代码次序（Source order） 后面的战胜之前的 继承规则决定后代元素是否继承祖先元素的某些属性值 2.6 盒模型盒模型Note:content（页面的主要内容）padding (分隔页面与边框的距离)border(边框大小)margin (分离与其他元素)关注 box-sizingbox-sizing 2.7 css布局(position/flex/grid)兼容性 position &gt; flex &gt; grid简易度 grid = flex &gt; position 2.7.1 positionposition (MDN)Note: position:static/relative/absoulte/fixed/sticky 注意absoulte定位 If there is no such parent, it will default all the way back up to the \\ element itself meaning it will be placed relatively to the page itself. 注意文档流的概念 lab:打开position文件夹下的html文件观察效果 2.7.2 flexflex (css-tricks的一篇文章)css-trick有许多比较好的css文章Note flex-basis(在其他元素分配剩余空间之前设定默认尺寸) 2.7.3 grid(补充)grid (css-tricks的一篇文章) 2.7.4 float定位(补充)lab:打开 float.html查看效果 2.7.5 高度塌缩(补充)高度塌缩问题 2.7.6 position 和flex冲突吗(补充)position 和flex冲突吗 2.8 css prefix2.8.1 为什么需要前缀？参考链接 试验一些还未成为标准的的CSS属性——也许永远不会成为标准 对新出现的标准的CSS3属性特征做实验性的实现 对CSS3中一些新属性做等效语义的个性实现 Android: -webkit-Chrome: -webkit-Safari: -webkit-iOS: -webkit-Firefox: -moz-Internet Explorer: -ms-Opera: -o- 2.8.2 如何加前缀？autoprefix工具 lab:打开prefix.css并将其中内容复制到autoprefix工具中查看结果 2.9 css预处理(stylus/sass/less…)预处理器的好处以及简单的对比stylus如何使用？","categories":[],"tags":[{"name":"learning material","slug":"learning-material","permalink":"http://cjkkkk.github.io/tags/learning-material/"}]},{"title":"javascript-arrow-function","slug":"javascript-arrow-function","date":"2018-12-31T07:34:08.000Z","updated":"2019-03-10T11:18:49.536Z","comments":true,"path":"2018/12/31/javascript-arrow-function/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-arrow-function/","excerpt":"","text":"1 前言请先看 -&gt; 如何理解this关键词 ES6中引入了一种无法使用4种this绑定规则的特殊函数类型,箭头函数(arrow function)箭头函数根据外层作用域来决定this(有词法作用域的味道) 2 例子看下面的两个例子 example #112345678910function x()&#123; this.a = 3//利用obj调用时候 this指向obj function y()&#123; this.a = 2//this指向全局对象了 &#125; y()&#125;var obj = &#123;&#125;x.apply(obj)console.log(obj,global.a)//&#123;a:3&#125; 2 可以看到上面函数x中的y函数的this指向的是全局对象，因为y的调用使用默认绑定改进方法如下 example #21234567891011function x()&#123; this.a = 3//利用obj调用时候 this指向obj that = this function y()&#123; that.a = 2//利用js闭包的特性记住了外部的this &#125; y()&#125;var obj = &#123;&#125;x.apply(obj)console.log(obj,global.a)//&#123;a:2&#125; undefined 3 更加优雅的箭头函数的方法example #312345678910function x()&#123; this.a = 3//利用obj调用时候 this指向obj var y = () =&gt;&#123;//不修改this this仍然指向obj this.a = 2 &#125; y()&#125;var obj = &#123;a:0&#125;x.apply(obj)console.log(obj)//&#123;a:2&#125; 这里箭头函数y中this是其词法作用域中的this，即x绑定的obj对象。箭头函数的绑定无法被更改，其this在函数定义的时候确定。常用于回调函数中 example 412345678function foo()&#123; setTimeout(function()&#123; console.log(this.a) &#125;,1000)&#125;obj = &#123;a:1&#125;foo.call(obj) // undefined 因为this绑定到全局对象上了 使用箭头函数进行改进 example 512345678function foo()&#123; setTimeout(()=&gt;&#123; console.log(this.a) &#125;,1000)&#125;obj = &#123;a:1&#125;foo.call(obj)//1 这里箭头函数记住了this为foo函数的this，所以调用了obj中的a属性 总结 ： 箭头函数不会采用四条标准的绑定规则，而是根据当前的词法作用域来决定this","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"javascript-prototype","slug":"javascript-prototype","date":"2018-12-31T07:28:14.000Z","updated":"2019-03-10T11:15:39.463Z","comments":true,"path":"2018/12/31/javascript-prototype/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-prototype/","excerpt":"","text":"1 前言javascript 是具有基于原型链的面向对象编程语言 oop != class oop 也不需要基于class 请先抛弃class关键词 2 在javascript中,对象来自于对象Object comes from Object。你可以使用对象来直接构造一个对象example #1123456var food = &#123; eat:\"i eat !\"&#125;var meal = Object.create(food)console.log(meal.eat) // \"i eat\" 现在我来解释下这里发生了什么,首先Object.create(source)方法创建了一个新的空对象,然后将新对象的原型设置为source即你传入对象。 2.1 首先来验证下meal确实是空对象console.log(meal) // {} 2.2 然后我们来验证meal的原型确实是foodmeal.__proto__ === food //true 2.3 你可能会问:等等!__proto__是什么？？？ 为什么meal.eat 输出了内容？？？2.3.1 先回答第一个问题:__proto__是什么？在javascript中所有的对象中都有一个内置属性__proto__,指向它的原型对象。在这个例子中meal的原型对象就是food所有对象的原型指向形成了链式结构，这就是原型链，而原型链的顶端就是Object.prototype meal.__proto -&gt;food food.__proto-&gt;Object.prototype Object.prototype的原型是null Object.prototype.__proto__ -&gt; null 知道这个原理之后我们就可以来模拟一下Object.create() example#21234567891011function ourNew(source)&#123; var obj = &#123;&#125; obj.__proto__ = source return obj&#125;var food = &#123; eat:\"i eat\"&#125;var meal = ourNew(food)console.log(meal.eat)//\"i eat\" 太棒了，我们模拟了一个对象的继承 2.3.2 再回答第二个问题:为什么meal.eat 输出了内容？js中对象属性的查找机制，是从对象本身开始查找，如果查找不到，则顺着原型链继续向上查找，直到找到对应属性后返回，否则返回undefined 即meal.__proto__.__proto__... 当原型链中存在相同属性时候,最先找到的会被返回，而上层的同名属性会被屏蔽 example #3123456789var food = &#123; eat:\"i eat !\"&#125;var meal = Object.create(food)console.log(meal.eat)//\"i eat\"meal.eat = \"i don't eat\"console.log(meal.eat)//\"i don't eat\"console.log(meal.__proto__.eat)//\"i eat\" oops! food的eat属性被meal屏蔽了 3 构造函数 new 关键词在js中我们还可以通过一类特殊的对象 – 函数 来构建对象，也就是我们经常说的构造函数。任何函数只要前面加上关键词new就会被当作是构造函数 example #41234567function Point(x,y)&#123; this.x = x this.y = y&#125;var point = new Point(1,2)console.log(point)//&#123;x:1,y:2&#125; 这其中发生了什么呢？ 1 首先一个对象被创建，对象的_proto_是Point.prototype即构造函数.prototype 2 将this绑定到这个对象，用参数构造这个对象，即 新创建对象的x 变为传入参数 x，新创建对象的y 变为传入参数的 y 3 如果构造函数没有显式返回一个对象，则返回新创建的对象 example #512345678function Point(x,y)&#123; this.x = x this.y = y return &#123;x:100,y:100&#125;//显式返回对象 覆盖新建立的对象&#125;var point = new Point(1,2)console.log(point)//&#123;x:100,y:100&#125; 所以在js中对象直接来自对象，不管你是用object.create() 还是 new function()来创建","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"javascript-this","slug":"javascript-this","date":"2018-12-31T07:18:09.000Z","updated":"2018-12-31T07:23:55.395Z","comments":true,"path":"2018/12/31/javascript-this/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/javascript-this/","excerpt":"","text":"1 前言：this 是javascript中一个重要的关键词 根据函数执行时候上下文的不同this代表的含义也不同 2 为什么使用thisthis提供了优雅的方式来隐式的传递一个对象的引用 this是在运行时候绑定的，并不是在编写的时候绑定的，它的上下文取决于函数调用时的条件。 this绑定规则有4种3 绑定机制3.1 不带任何修饰的函数调用 -默认绑定没有任何修饰，即没有使用apply/call，也没有显式的对象包含 比如 object.somefunction() 12345678a = 1function fun()&#123; console.log(this.a)&#125;fun()//使用默认绑定，非严格模式下是全局对象 window，//调用window的a属性,即1；严格模式下为undefined，发生错误 3.2 隐式绑定被对象拥有或者包含时候使用隐式绑定，this指向调用对象 12345678910let a = 2function fun()&#123; console.log(this.a)&#125;const obj = &#123; a:1, fun:fun&#125;obj.fun()//1 但此时需要注意一种隐式丢失的情况 1234567891011let a = 2function fun()&#123; console.log(this.a)&#125;const obj = &#123; a:1, fun:fun&#125;let anotherfun = obj.funanotherfun()//2,anotherfun是fun的别名或者说引用，此时没有任何修饰,使用默认绑定 对象属性引用链中只有最后一条会影响调用12345678910111213141516function foo()&#123; console.log(this.a)&#125;let obj2 = &#123; a:42, foo:foo&#125;let obj1 = &#123; a:2, obj2:obj2&#125;obj1.obj2.foo()//42 3.3 显示绑定使用call/apply/bind进行硬绑定123456789101112function foo()&#123; console.log(this.a)&#125;obj=&#123; a:1&#125;foo.call(obj) // 1foo.apply(obj) // 1let foo_with_obj = foo.bind(obj)foo_with_obj()//1 3.4 new关键词绑定new的执行过程1 创建一个全新的对象2 绑定原型链3 新对象绑定到函数调用的this4 函数没有返回其他对象，那么返回新对象 可以看到第3步中，new关键词，会将新对象绑定到调用函数的this上 4 绑定的优先级new &gt; 显示 &gt; 隐式 &gt; 默认 证明 显式 &gt; 隐式 123456789101112131415161718function foo()&#123; console.log(this.a)&#125;obj1= &#123; a:1, foo:foo&#125;obj2=&#123; a:2, foo:foo&#125;obj1.foo()//1obj2.foo()//2obj1.foo.call(obj2)//2obj2.foo.call(obj1)//1 证明 new优先级高于显示绑定123456789101112function foo(something)&#123; this.a= something&#125;let obj = &#123;&#125;let bar = foo.bind(obj)bar(2)console.log(obj.a)//2let baz = new bar(3)console.log(obj.a)//2console.log(baz.a)//3 5 apply/call/bind 使用 null作为绑定对象此时为默认绑定如果你的函数不会修改this，那么可以放心传入否则，你的函数会在全局对象上产生可怕的修改12345678910function foo(x)&#123; this.x = x&#125;let obj = &#123;&#125;foo.apply(obj, [2])console.log(obj.x)//2foo.apply(null, [3])console.log(global.x)// 2 3 5.1 避免不必要的默认绑定可以使用一个空的DMZ对象进行绑定12345function foo()&#123; this.a = 1&#125;valet SPECIAL_OBJ = Object.create(null)//空对象&#123;&#125;foo.call(SPECIAL_OBJ)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://cjkkkk.github.io/tags/javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-12-31T06:51:40.746Z","updated":"2018-12-31T06:51:40.746Z","comments":true,"path":"2018/12/31/hello-world/","link":"","permalink":"http://cjkkkk.github.io/2018/12/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}